{
  "p5": {
    "alpha": {
      "description": "Extrae el valor de alpha de un color o de un arreglo de pixeles.",
      "params": ["Objeto: objeto p5.Color o arreglo de pixeles"],
      "returns": "the p5 object"
    },
    "blue": {
      "description": "Extrae el valor de azul de un color o de un arreglo de pixeles.",
      "params": ["Objeto: objeto p5.Color o arreglo de pixeles"],
      "returns": "the p5 object"
    },
    "brightness": {
      "description": "Extrae el valor de brillo HSB de un color o de un arreglo de pixeles.",
      "params": ["Objeto: objeto p5.Color o arreglo de pixeles"],
      "returns": "the p5 object"
    },
    "color": {
      "description": "Crea colores para ser almacenados en variables del tipo color. Los parámetros son interpretados como valores RGB o HSB, dependiendo del modo actual de color según colorMode)(). El modo por defecto es RGB con valores entre 0 y 255 y, por lo tanto, la función color(255, 204, 0) retorna un color amarillo brillante. Nota que si solo se provee un valor a la función color(), será interpretado como un valor en escala de grises. Añade un segundo valor, y será usado como transparencia alpha. Cuando se especifican tres valores, son interpretados como valores RGB o HSB. Al añadir un cuarto valor se aplica transparencia alpha. Si se provee solo un parámetro de tipo string, será interpretado como un string de color compatible con CSS.Los colores son almacenados como números o arreglos.",
      "params": ["Número|String: número especificando el valor entre blanco y negro.",
      "Número: valor de alpha relativo al rango de color actual (por defecto es 0-100)",
      "Número|String: valor de rojo o tinte relativo al rango de color actual, o un string de color",
      "Número: valor de verde o saturación relativo al rango de color actual",
      "Número: valor de azul o brillo relativo al rango de color actual"],
      "returns": "Arreglo: color resultante"
    },
    "green": {
      "description": "Extrae el valor de verde de un color o de un arreglo de pixeles.",
      "params": ["Objeto: objeto p5.Color o arreglo de pixeles"],
      "returns": "the p5 object"
    },
    "hue": {
      "description": "Extrae el valor de tinte de un color o de un arreglo de pixeles. El tinte (hue) existe en HSB y HSL. Esta función retorna el tinte normalizado HSB que cuando se le provee un objeto de color HSB (o cuando se le provee un arreglo de pixeles mientras el modo de color es HSB), pero por defecto retornará el tinte normalizado según HSB en otro caso. (Estos valores solo son diferentes si la configuración de valor de tinte máximo de cada sistema es diferente.)",
      "params": ["Objeto: objeto p5.Color o arreglo de pixeles"],
      "returns": "the p5 object"
    },
    "lerpColor": {
      "description": "Mezcla dos colores para encontrar un tercer color según la combinación de ambos. El parámetro amt es la cantidad a interpolar entre los dos valores, donde 0.0 es igual al primer color, 0.1 es muy cercano al primer color, 0.5 está a medio camino entre ambos, etc. Un valor menor que 0 será tratado como 0. Del mismo modo, valores sobre 1 serán tratados como 1. Esto es distinto al comportamiento de lerp(), pero necesario porque de otra manera los números fuera de rango producirían colores no esperados y extraños. La manera en que los colores son interpolados depende del modo de color actual.",
      "params": ["Arreglo/Número: interpola desde este color",
      "Arreglo/Número: interpola hacia este color",
      "Número: número entre 0 y 1"],
      "returns": "Arreglo/Número: color interpolado"
    },
    "lightness": {
      "description": "Extrae el valor de luminosidad HSL de un color o de un arreglo de pixeles.",
      "params": ["Objeto: objeto p5.Color o arreglo de pixeles"],
      "returns": "the p5 object"
    },
    "red": {
      "description": "Extrae el valor de rojo de un color o de un arreglo de pixeles.",
      "params": ["Objeto: objeto p5.Color o arreglo de pixeles"],
      "returns": "the p5 object"
    },
    "saturation": {
      "description": "Extrae el valor de saturación de un color o de un arreglo de pixeles. La saturación es escalada en HSB y HSL de forma distinta. Esta función retornará la saturación HSB cuando le sea provisto un objeto de color HSB (o cuando le sea provisto un arreglo de pixeles mientras el modo de color es HSB), pero por defecto retornará saturación HSL.",
      "params": ["Objeto: objeto p5.Color o arreglo de pixeles"],
      "returns": "the p5 object"
    },
    "background": {
      "description": "La función background() define el color usado como fondo del lienzo p5.js. El fondo por defecto es gris claro. Esta función es típicamente usada dentro de draw() para despejar o borrar la ventana mostrada al inicio de cada cuadro, pero puede ser usada dentro de setup() para definir el fondo en el primer cuadro de la animación o si el fondo solo necesita ser definido una vez.",
      "params": ["Color: cualquier valor creado con la función color()",
               "Número: opacidad del fondo relativo al rango de color actual (por defecto es 0-100)",
               "colorstring: string de color, formatos posibles: enteros rgb() o rgba(), porcentajes rgb() o rgba(), hex 3 dígitos, hex 6 dígitos",
               "Número: especifica un valor entre blanco y negro",
               "Número: valor de rojo o hue (dependiendo del modo de color actual)",
               "Número: valor de verde o saturación (dependiendo del modo de color actual)",
               "Número: valor de azul o brillo (dependiendo del modo de color actual)",
               "p5.Image: imagen creada con loadImage() o createImage(), para ser definida como fondo (debe ser del mismo tamaño que la ventana del bosquejo)"],
      "returns": "the p5 object"
    },
    "clear": {
      "description": "Borra los pixeles del buffer. Esta función solo funciona en objetos p5.Canvas creados con la función createCanvas(); no funcionará con la ventana principal. A diferencia del contexto principal de gráficas, los pixeles en las áreas gráficas adicionales creadas con createGraphics() pueden ser entera o parcialmente transparentes. Esta función borra todo para hacer los pixeles 100% transparentes.",
      "returns": "the p5 object"
    },
    "colorMode": {
      "description": "colorMode() cambia la manera en que p5.js interpreta los datos de color. Por defecto, los parámetros de fill(), stroke(), background() y color() son definidos por valores entre 0 y 255 en modo RGB. Esto es equivalente a definir el modo de color según colorMode(RGB, 255). Definir el modo de color en colorMode(HSB) permite usar el sistema HSB. Por defecto, este modo de color es colorMode(HSB, 360, 100, 100, 1). También se puede usar HSL. Nota: los objetos de color existentes recuerdan el modo en que fueron creados, por lo que puedes cambiar el modo como quieras, sin afectar su apariencia.",
      "params": ["Constante: RGB o HSB, correspondiente a Rojo/Verde/Azul o tinte/saturación/brillo (o luminosidad)",
      "Número: rango de rojo o tinte, dependiendo del modo de color actual, o rango para todos los valores",
      "Número: rango de verde o saturación, dependiendo del modo de color actual.",
      "Número: rango de azul o brillo/luminosidad, dependiendo del modo de color actual.",
      "Número: rango de transparencia alpha"],
      "returns": "the p5 object"
    },
    "fill": {
      "description": "Define el color usado para el relleno de figuras geométricas. Por ejemplo, si ejecutas fill(204, 102, 0), todas las figuras a continuación tendrán relleno naranja. Este color es especificado en términos de color RGB o HSB, dependiendo del modo de color según colorMode() (el dominio de color por defecto es RGB, con cada valor en el rango entre 0 y 255). Si se provee un argumento tipo string, los tipos RGB, RGBA y CSS hexadecimal están soportados. Un objeto Color p5 puede ser provisto para definir el color del relleno.",
      "params": ["Número|Arreglo|String|p5.Color: valor de gris, rojo, tinte (dependiendo del modo de color actual), o arreglo de color, o string de color CSS.",
      "Número: valor de verde o saturación (dependiendo del modo de color actual)",
      "Número: valor de azul o brillo (dependiendo del modo de color actual)",
      "Número: opacidad del fondo"],
      "returns": "the p5 object"
    },
    "noFill": {
      "description": "Deshabilita el relleno de figuras geométricas. Si tanto noStroke() como noFill() son ejecutados, nada será dibujado en pantalla.",
      "returns": "the p5 object"
    },
    "noStroke": {
      "description": "Deshabilita el dibujo de los trazos (bordes). Si tanto noStroke() como noFill() son ejecutados, nada será dibujado en pantalla.",
      "returns": "the p5 object"
    },
    "stroke": {
      "description": "Define el color usado para dibujar líneas y bordes de figuras. Este color especificado en términos de color RGB o HSB, dependiendo del modo de color actual según colorMode() (el dominio de color por defecto es RGB, con cada valor en el rango entre 0 y 255). Si se provee un argumento tipo string, los tipos RGB, RGBA y CSS hexadecimal están soportados. Un objeto Color p5 puede ser provisto para definir el color del trazado.",
      "params": ["Número|Arreglo|String|p5.Color: valor de gris, rojo, tinte (dependiendo del modo de color actual), o arreglo de color, o string de color CSS.",
      "Número: valor de verde o saturación (dependiendo del modo de color actual)",
      "Número: valor de azul o brillo (dependiendo del modo de color actual)",
      "Número: opacidad del fondo"],
      "returns": "the p5 object"
    },
    "arc": {
      "description": "Dibuja un arco en la pantalla. Si se llama con solo a, b, c, d, start y stop, el arco se dibuja como un pastel abierto. Si el modo se provee, el arco será dibujado abierto, o como acorde, o como pastel, según lo especificado. El origen puede ser cambiado con la función ellipseMode(). Nota que si dibujas un círculo completo (ej: 0 a TWO_PI) aparecerá en blanco, porque 0 y TWO_PI son la misma posición en el círculo unitario. La mejor manera de manejar esto es usar la función ellipse() para una elipse cerrada, y la función arc() para generar solo secciones de una elipse.",
      "params": ["Número: coordenada x del arco de elipse.",
      "Número: coordenada y del arco de elipse.",
      "Número: ancho del arco de elipse.",
      "Número: altura del arco de elipse.",
      "Número: ángulo inicial del arco de elipse.",
      "Número: ángulo final del arco de elipse.",
      "Constante: parámetro opcional para determinar la manera de dibujar el arco."],
      "returns": "the p5 object"
    },
    "ellipse": {
      "description": "Dibuja una elipse (óvalo)  en la pantalla. Una elipse con igual ancho y altura es un círculo. Por defecto, los primeros dos parámetros definen la ubicación, y el tercero y cuarto definen el ancho y altura de la figura. Si no especifica una altura, el valor del ancho es usado como ancho y altura. El origen puede ser cambiado con la función ellipseMode().",
      "params": ["Número: coordenada x de la elipse.",
      "Número: coordenada y de la elipse.",
      "Número: ancho de la elipse.",
      "Número: altura de la elipse."],
      "returns": "the p5 object"
    },
    "line": {
      "description": "Dibuja una línea (un camino directo entre dos puntos) en la pantalla. La versión de line() con cuatro parámetros dibuja la línea en 2D. Para darle color a una línea, usa la función stroke(). Una línea no puede ser rellenada, por lo que la función fill() no afectará el color de una línea. Las líneas 2D son dibujadas con una ancho de un pixel por defecto, pero esto puede ser cambiado con la función strokeWeight().",
      "params": ["Número: coordenada x del primer punto.",
      "Número: coordenada y del primer punto.",
      "Número: coordenada x del segundo punto.",
      "Número: coordenada y del segundo punto."],
      "returns": "the p5 object"
    },
    "point": {
      "description": "Dibuja un punto, una coordenada en el espacio de un pixel de dimensión. El primer parámetro es la coordenada horizontal del punto, el segundo valor es la coordenada vertical del punto. El color del punto es determinado por el trazado actual con la función stroke().",
      "params": ["Número: coordenada x.",
      "Número: coordenada y ."],
      "returns": "the p5 object"
    },
    "quad": {
      "description": "Dibuja un cuadrilátero, un polígono de cuatro lados. Es similar a un rectángulo, pero los ángulos entre sus bordes no están limitados a noventa grados. El primer par de parámetros (x1, y1) corresponde a las coordenadas del primer vértice y los pares siguientes deben seguir en el mismo orden, según las manecillas del reloj o en contra, alrededor de la figura a definir.",
      "params": ["Número: coordenada x del primer punto.",
      "Número: coordenada y del primer punto.",
      "Número: coordenada x del segundo punto.",
      "Número: coordenada y del segundo punto.",
      "Número: coordenada x del tercer punto.",
      "Número: coordenada y del tercer punto.",
      "Número: coordenada x del cuarto punto.",
      "Número: coordenada y del cuarto punto."],
      "returns": "the p5 object"
    },
    "rect": {
      "description": "Dibuja un rectángulo en la pantalla. Un rectángulo es una figura de cuatro lados con cada ángulo interior de noventa grados. Por defecto, los dos primeros parámetros definen la ubicación de la esquina superior izquierda, el tercero el ancho y el cuarto la altura. La manera en que estos parámetros son interpretados, sin embargo, puede ser cambiado con la función rectMode(). Los parámetros quinto, sexto, séptimo y octavo, si son especificados, determinan el radio de la esquina superior derecha, superior izquierda, inferior derecha e inferior izquierda, respectivamente. Si se omite un parámetro de radio de esquina, se usa el radio especificado por el valor anterior en la lista.",
      "params": ["Número: coordenada x del rectángulo.",
      "Número: coordenada y del rectángulo.",
      "Número: ancho del rectángulo.",
      "Número: altura del rectángulo.",
      "Número: radio opcional de la esquina superior izquierda.",
      "Número: radio opcional de la esquina superior derecha.",
      "Número: radio opcional de la esquina inferior derecha.",
      "Número: radio opcional de la esquina inferior izquierda.",
      "Número:",
      "Número:"],
      "returns": "the p5 object"
    },
    "triangle": {
      "description": "Un triángulo es un plano creado por la conexión de tres puntos. Los primeros dos argumentos especifican el primer punto, los parámetros centrales especifican el segundo punto, y los dos últimos parámetros especifican el tercer punto.",
      "params": ["Número: coordenada x del primer punto.",
      "Número: coordenada y del primer punto.",
      "Número: coordenada x del segundo punto.",
      "Número: coordenada y del segundo punto.",
      "Número: coordenada x del tercer punto.",
      "Número: coordenada y del tercer punto."],
      "returns": "the p5 object"
    },
    "ellipseMode": {
      "description": "Modifica la ubicación de donde las elipses son dibujadas, cambiando la manera en que los parámetros dados a ellipse() son interpretados. El modo por defecto es ellipseMode(CENTER), que interpreta los dos primeros parámetros de ellipse() como el centro de la figura, mientras que los parámetros tercero y cuarto son el ancho y la altura. ellipseMode(RADIUS) también usa los dos primeros parámetros de ellipse() como el punto central de la figura, pero usa los parámetros tercero y cuarto para especificar la mitad del ancho y la altura de la figura. ellipseMode(CORNER) interpreta los dos primeros parámetros de ellipse() como la esquina superior izquierda de la figura, mientras que los parámetros tercero y cuarto son el ancho y la altura. ellipseMode(CORNERS) interpreta los dos primeros parámetros de ellipse() como la ubicación de una esquina del rectángulo contenedor de la elipse, y los parámetros tercero y cuarto como la ubicación de la esquina opuesta. El parámetro debe ser escrito en MAYÚSCULAS porque Javascript es una lenguaje de programación que distingue entre mayúsculas y minúsculas.",
      "params": ["Constante: puede ser CENTER, RADIUS, CORNER, o CORNERS."],
      "returns": "the p5 object"
    },
    "noSmooth": {
      "description": "Dibuja las figuras geométricas con bordes no suaves (aliasing). Notar que smooth() está activo por defecto, así que es necesario ejectuar noSmooth() para deshabilitar el suavizado de las figuras geométricas, imágenes y tipografías.",
      "returns": "the p5 object"
    },
    "rectMode": {
      "description": "Modifica la ubicación en que los rectángulos son dibujados, cambiando la manera en que los parámetros dados a rect() son interpretados. El modo por defecto es rectMode(CORNER), que interpreta los primeros dos parámetros de rect() como la esquina superior izquierda de la figura, mientras que los parámetros tercero y cuarto son su ancho y altura. rectMode(CORNERS) interpreta los dos primeros parámetros de rect() como la ubicación de una esquina, y los parámetros tercero y cuarto como la ubicación de la esquina opuesta. rectMode(CENTER) interpreta los dos primeros parámetros de rect() como el punto central de la figura, mientas que los parámetros tercero y cuarto son su ancho y altura. rectMode(RADIUS) también usa los dos primeros parámetros de rect()= como el punto central de la figura, pero usa los parámetros tercero y cuarto para especificar la mitad del ancho y la altura de la figura. Los parámetros deben ser escritos en MAYÚSCULAS porque Javascript es un lenguaje que distingue entre mayúsculas y minúsculas.",
      "params": ["Constante: puede ser CORNER, CORNERS, CENTER, o RADIUS."],
      "returns": "the p5 object"
    },
    "smooth": {
      "description": "Dibuja todas las figuras geométricas con bordes suaves (sin aliasing). smooth() también mejorará la calidad de las imágenes cuyo tamaño ha sido modificado. Notar que smooth() está activo por defecto; noSmooth() puede ser usado para deshabilitar el suavizado de las figuras geométricas, imágenes y tipografía.",
      "returns": "the p5 object"
    },
    "strokeCap": {
      "description": "Define el estilo de rendering de los extremos de las líneas. Estos extremos pueden ser cuadrados, extendidos o redondeados, cada uno de estos especifados con los parámetros correspondientes: SQUARE, PROJECT, y ROUND. El extremo por defecto es redonedeado (ROUND).",
      "params": ["Constante: puede ser SQUARE, PROJECT, o ROUND."],
      "returns": "the p5 object"
    },
    "strokeJoin": {
      "description": "Define el estilo de las uniones que conectan segmentos de líneas. Estas uniones pueden ser tipo inglete, biseladas o redondeadas, y especificadas con los parámetros correspondientes: MITER, BEVEL, y ROUND. La unión por defecto es MITER.",
      "params": ["Constante: puede ser MITER, BEVEL, o ROUND."],
      "returns": "the p5 object"
    },
    "strokeWeight": {
      "description": "Define el ancho del trazo usado para dibujar líneas, puntos y los bordes de las figuras geométricas. Todos los anchos son medidos en pixeles.",
      "params": ["Número: el peso (en pixeles) del trazado"],
      "returns": "the p5 object"
    },
    "bezier": {
      "description": "Dibuja una curva Bezier cúbica en la pantalla. Estas curvas están definidas por una serie de puntos ancla y de control. Los primeros dos parámetros especifican el primer punto ancla y los dos últimos especifican el otro punto ancla, que se convierten en los puntos primero y último de la curva. Los parámetros en el medio especifican los dos puntos de control que definen la forma de la curva. De forma aproximada, los puntos de control atraen la curva hacia ellos. Las curvas Bezier fueron desarrolladas por el ingeniero automotriz Pierre Bezier, y son comúnmente usadas en gráficas computacionales para definir curvas de pendiente suave. Ver también curve().",
      "params": ["Número: coordenada x del primer punto ancla",
      "Número: coordenada y del primer punto ancla",
      "Número: coordenada x del primer punto de control",
      "Número: coordenada y del primer punto de control",
      "Número: coordenada x del segundo punto de control",
      "Número: coordenada y del segundo punto de control",
      "Número: coordenada x del segundo punto ancla",
      "Número: coordenada y del segundo punto ancla",
      "Número: coordenada z del primer punto ancla",
      "Número: coordenada z del primer punto de control",
      "Número: coordenada z del segundo punto ancla",
      "Número: coordenada z del segundo punto de control"],
      "returns": "the p5 object"
    },
    "bezierPoint": {
      "description": "Evalua la curva Bezier en la posición t para los puntos a, b, c, d. Los parámetros a y d son los puntos primero y último de la curva, mientras que b y c son los puntos de control. El parámetro final t varía entre 0 y 1. Esto puede ser realizado una vez con las coordenadas x y una segunda vez con las coordenadas y para obtener la ubicación de la curva Bezier en t.",
      "params": ["Número: coordenada del primer punto de la curva",
      "Número: coordenada del primer punto de control de la curva",
      "Número: coordenada del segundo punto de control de la curva",
      "Número: coordenada del segundo punto de la curva",
      "Número: valor entre 0 y 1"],
      "returns": "el valor de la curva Bezier en la posición t"
    },
    "bezierTangent": {
      "description": "Evalua la tangente de la curva Bezier en la posición t para los puntos a, b, c, d. Los parámetros a y d son los puntos primero y último de la curva, mientras que b y c son los puntos de control. El parámetro final t varía entre 0  1.",
      "params": ["Número: coordenada del primer punto de la curva",
      "Número: coordenada del primer punto de control de la curva",
      "Número: coordenada del segundo punto de control de la curva",
      "Número: coordenada del segundo punto de la curva",
      "Número: valor entre 0 y 1"],
      "returns": "la tangente en la posición t"
    },
    "curve": {
      "description": "Dibuja una línea curva en la pantalla entre dos puntos, dados como los cuatro parámetros centrales. Los dos primeros puntos son un punto de control, como si la curva viniera desde este punto, aunque no sea dibujado. Los dos últimos parámetros de forma similar describen el otro punto de control. SE pueden cerar curvas más largas, por medio del posicionamiento de varias funciones curve() juntas o usando curveVertex(). Una función adicional llamada curveTightness() provee control de la calidad visual de la curva. La función curve() es una implementación de la Catmull-Rom spline.",
      "params": ["Número: coordenada x del punto de control inicial",
      "Número: coordenada y del punto de control inicial",
      "Número: coordenada x del primer punto",
      "Número: coordenada y del primer punto",
      "Número: coordenada x del segundo punto",
      "Número: coordenada y del segundo punto",
      "Número: coordenada x del punto de control final",
      "Número: coordenada y del punto de control final",
      "Número: coordenada z del punto de control inicial",
      "Número: coordenada z del primer punto",
      "Número: coordenada z del segundo punto",
      "Número: coordenada z del punto de control final"],
      "returns": "Objeto: el objeto p5"
    },
    "curveTightness": {
      "description": "Modifica la calidad de las formas creadas con curve() y curveVertex(). El parámetro tightness (tirantez) determina cómo la curva calza con los vértices. El valor 0.0 es el valor por defecto (este valor define las curvas Spline Catmull-Rom) y el valor 1.0 conecta todos los puntos con líneas rectas. Valores en el rango entre -5.0 y 5.0 deformarán las curvas pero las dejarán reconocibles, y a medida que los valores crecen en magnitud, se continuarán deformando.",
      "params": ["Número: deformación de los vértices originales"],
      "returns": "the p5 object"
    },
    "curvePoint": {
      "description": "Evalua la curva en la posición t para los puntos a, b, c, d. El parámetro t varía entre 0 y 1, los puntos a y d son puntos en la cruva, y b y c son los puntos de control. Esto puede ser hecho una vez con las coordenadas x y una segunda vez con las coordenadas y para obtener la ubicación de la curva en t.",
      "params": ["Número: coordenada del primer punto de la curva",
        "Número: coordenada del primer punto de control de la curva",
        "Número: coordenada del segundo punto de control de la curva",
        "Número: coordenada del segundo punto de la curva",
        "Número: valor entre 0 y 1"],
      "returns": "the p5 object"
    },
    "curveTangent": {
      "description": "Evalua la tangente de la curva en la posición t para los puntos a, b, c, d. El parámetro t varía entre 0 y 1, a y d son los puntos de la curva, b y c son los puntos de control.",
      "params": ["Número: coordenada del primer punto de la curva",
        "Número: coordenada del primer punto de control de la curva",
        "Número: coordenada del segundo punto de control de la curva",
        "Número: coordenada del segundo punto de la curva",
        "Número: valor entre 0 y 1"],
      "returns": "la tangente en la posición t"
    },
    "beginContour": {
      "description": "Usa las funciones beginContour() y endContour() para crear figuras negativas dentro de figuras como el centro de la letra 'O'. beginContour() empieza la grabación de los vértices para la figura y endContour() finaliza la grabación. Los vértices que definen una figura negativa deben ser definidos en la dirección opuesta a la figura exterior. Primero dibuja los vértices de la figura exterior en el orden de las manecillas del reloj, y luego para figuras internas, dibuja vértices en el sentido contrario a las manecillas del reloj. Estas funciones solo pueden ser usadas dentro de un par beginShape()/endShape() y transformaciones como translate(), rotate(), y scale() no funcionan dentro de un par beginContour()/endContour(). Tampoco es posible usar otras figuras, como elupse() o rect() dentro.",
      "returns": "el objeto p5"
    },
    "beginShape": {
      "description": "El uso de las funciones beginShape() y endShape() permiten la creación de figuras más complejas. beginShape() empieza la grabación de vértices para una figura, mientras que endShape() termina la grabación. El valor del parámetro kind (tipo) define qué tipo de figuras serán creadas a partir de los vértices. Si no se especifica un modo, la figura puede ser cualquier polígono irregular. Los parámetros disponibles para beginShape() son POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, y QUAD_STRIP. Después de llamar a la función beginShape(), debe ser seguida por una serie de comandos vertex(). Para detener el dibujo de la figura, ejecuta endShape(). Cada figura será dibujada con el color de trazo y el color de relleno actual. Transformaciones como translate(), rotate(), y scale() no funcionan dentro de beginShape(). Tampoco es posible usar otras figuras como ellipse() o rect() dentro de beginShape().",
      "params": ["Constante: puede ser POINTS, LINES, TRIANGLES, TRIANGLE_FAN TRIANGLE_STRIP, QUADS, o QUAD_STRIP"],
      "returns": "el objeto p5"
    },
    "bezierVertex": {
      "description": "Especifica las coordenadas de un vértice para una curva Bezier. Cada llamada a la función bezierVertex() define la posición de dos puntos de control y un punto ancla de una curva Bezier, añadiendo un nuevo segmento a la línea o figura. La primera vez que bezierVertex() es usada dentro de una llamada a beginShape(), debe ser antecedida por una llamada a la función vertex() para definir el primer punto ancla. Esta función debe ser usada entre beginShape() y endShape() y solo cuando no se ha especificado el parámetro MODE (modo) a beginShape().",
      "params": ["Número: coordenada x del primer punto de control la curva",
        "Número: coordenada y del primer punto de control la curva",
        "Número: coordenada x del segundo punto de control la curva",
        "Número: coordenada y del segundo punto de control la curva",
        "Número: coordenada x del primer punto ancla",
        "Número: coordenada y del primer punto ancla"],
      "returns": "el objeto p5"
    },
    "curveVertex": {
      "description": "Especifica las coordenadas de un vértice para una curva. Esta función solo puede ser usada entre beginShape() y endShape() y cuando no se ha especificado el parámetro MODE en la función beginShape(). Los puntos primero y último en una serie de líneas curveVertex() serán usados para guiar el inicio y final de una curva. Un mínimo de cuatro puntos es requerido para dibujar una pequeña curva entre los puntos segundo y tercero, Añadir un quinto punto con curveVertex() dibujará la curva entre los puntos segundo, tercero y cuarto. La función curveVertex() es una implementación de las splines de Catmull-Rom.",
      "params": ["Número: coordenada x del vértice",
        "Número: coordenada y del vértice"],
      "returns": "el objeto p5"
    },
    "endContour": {
      "description": "Usa las funciones beginContour() y endContour() para crear figuras negativas dentro de figuras como el centro de la letra 'O'. beginContour() empieza la grabación de los vértices para la figura y endContour() finaliza la grabación. Los vértices que definen una figura negativa deben ser definidos en la dirección opuesta a la figura exterior. Primero dibuja los vértices de la figura exterior en el orden de las manecillas del reloj, y luego para figuras internas, dibuja vértices en el sentido contrario a las manecillas del reloj. Estas funciones solo pueden ser usadas dentro de un par beginShape()/endShape() y transformaciones como translate(), rotate(), y scale() no funcionan dentro de un par beginContour()/endContour(). Tampoco es posible usar otras figuras, como elupse() o rect() dentro.",
      "returns": "el objeto p5"
    },
    "endShape": {
      "description": "La función endShape() es compañera de la función beginShape() y solo puede ser ejecutada tras la ejecución de beginShape(). Cuando endshape() es ejecutada, todos los datos de imagen definidos desde la llamada anterior a beginShape() son escritos en el buffer de imagen. La constante CLOSE se usa como valor para el parámetro MODE para cerrar la figura (para conectar el comienzo con el final).",
      "params": ["Constante: usa CLOSE para cerrar la figura."],
      "returns": "el objeto p5"
    },
    "quadraticVertex": {
      "description": "Especifica las coordenadas de vértices par curvas Bezier cuadráticas. Cada llamada a quadraticVertex() define la posición de uno de los puntos de control y ancla de una curva Bezier, añadiendo un nuevo segmento a la línea o figura. La primera vez que quadraticVertex() es usada dentro de una llamada a beginShape(), debe ser precedida por una llamada a la función vertex() para definir el primer punto ancla. Esta función debe ser usada entre un par beginShape() y endShape() y solo cuando no se ha especificado el parámetro MODE de beginShape().",
      "params": ["Número: coordenada x del punto de control",
        "Número: coordenada y del punto de control",
        "Número: coordenada x del punto ancla",
        "Número: coordenada y del punto ancla"],
      "returns": "el objeto p5"
    },
    "vertex": {
      "description": "Todas las figuras son construidas mediante la conexión de una serie de vértices. vertex() es usado para especificar las coordenadas de los vértices para puntos, líneas, triángulos, cuadriláteros y polígonos. Es usada exclusivamente dentro de un par de funciones beginShape() y endShape().",
      "params": ["Número: coordenada x del vértice",
        "Número: coordenada y del vértice"],
      "returns": "el objeto p5"
    },
    "loadModel": {
      "description": "Carga un modelo 3d desde un archivo OBJ. Una de las limitaciones del formato OBJ es que no trae incorporado un sentido de escala. Esto significa que los modelos exportados por distintos programas pueden ser de tamaños radicalmente distintos. Si tu modelo no está siendo mostrado en pantalla, trata llamando a la función loadMode() con el parámetro de normalización configurado como verdadero. Esto escalará el tamaño del modelo a una escala apropiada para p5. También puedes hacer cambios adicionales al tamaño final de tu modelo con la función scale().",
      "params": ["String: ubicación del modelo a cargar",
        "Boolean:  Si es verdadero (true), escala el modelo a un tamaño estandarizado al momento de cargarlo.",
        "Función(p5.Geometry3D): función a ser llamada cuando el modelo se cargue. Será pasada al modelo del objeto 3D.",
        "Función(evento): llamada con el error evento si la imagen no falla al cargar."],
      "returns": "el objeto p5.Geometry3D"
    },
    "model": {
      "description": "Hace el render de un modelo 3D en la pantalla.",
      "params": ["p5.Geometry: modelo 3D cargado para realizar render"],
      "returns": "el objeto p5"
    },
    "plane": {
      "description": "Dibuja un plano con ancho y altura dados.",
      "params": ["Número: ancho del plano",
      "Número: altura del plano",
      "Número: número opcional de subdivisiones triangulares en la dimensión x",
      "Número: número opcional de subdivisiones triangulares en la dimensión y"],
      "returns": "el objeto p5"
    },
    "box": {
      "description": "Dibuja una caja con ancho, altura y profundidad dados.",
      "params": ["Número: ancho de la caja",
      "Número: altura de la caja",
      "Número: profundidad de la caja",
      "Número: número opcional de subdivisiones triangulares en la dimensión x",
      "Número: número opcional de subdivisiones triangulares en la dimensión y"],
      "returns": "el objeto p5"
    },
    "sphere": {
      "description": "Dibuja una esfera de radio dado.",
      "params": ["Número: radio del círculo",
      "Número: opcional, número de segmentos, a mayor número de segmentos la geometría es más suave, por defecto es 24",
      "Número: opcional, número de segmentos, a mayor número de segmentos la geometría es más suave, por defecto es 16"],
      "returns": "el objeto p5"
    },
    "cylinder": {
      "description": "Dibuja un cilindro de radio y altura dados.",
      "params": ["Número: radio de la superficie",
      "Número: altura del cilindro",
      "Número: opcional, número de segmentos, a mayor número de segmentos la geometría es más suave, por defecto es 24",
      "Número: opcional, número de segmentos, a mayor número de segmentos la geometría es más suave, por defecto es 16"],
      "returns": "el objeto p5"
    },
    "cone": {
      "description": "Dibuja un cono de radio y altura dados.",
      "params": ["Número: radio de la superficie inferior",
      "Número: altura del cono",
      "Número: opcional, número de segmentos, a mayor número de segmentos la geometría es más suave, por defecto es 24",
      "Número: opcional, número de segmentos, a mayor número de segmentos la geometría es más suave, por defecto es 16"],
      "returns": "el objeto p5"
    },
    "ellipsoid": {
      "description": "Dibuja un elipsoide de radio dado.",
      "params": ["Número: radio x del círculo",
      "Número: radio y del círculo",
      "Número: radio z del círculo",
      "Número: opcional, número de segmentos, a mayor número de segmentos la geometría es más suave, por defecto es 24. Evita números mayores a 150 que podrían colapsar el navegador.",
      "Número: opcional, número de segmentos, a mayor número de segmentos la geometría es más suave, por defecto es 16. Evita números mayores a 150 que podrían colapsar el navegador."],
      "returns": "el objeto p5"
    },
    "torus": {
      "description": "Dibuja un toroide con radio y tubo dado.",
      "params": ["Número: radio del anillo completo",
      "Número: radio del tubo",
      "Número: radio z del círculo",
      "Número: opcional, número de segmentos, a mayor número de segmentos la geometría es más suave, por defecto es 24.",
      "Número: opcional, número de segmentos, a mayor número de segmentos la geometría es más suave, por defecto es 16."],
      "returns": "el objeto p5"
    },
    "HALF_PI": {
      "description": "HALF_PI es una constante matemática de valor 1.57079632679489661923. Es la mitad de la razón entre la circunferencia de un círculo y su diámetro. Es útil en combinación con las funciones trigonométricas sin() y cos().",
      "returns": "el objeto p5"
    },
    "PI": {
      "description": "PI es una constante matemática de valor 3.14159265358979323846. Es la razón entre la circunferencia de un círculo y su diámetro. Es útil en combinación con las funciones trigonométricas sin() y cos().",
      "returns": "el objeto p5"
    },
    "QUARTER_PI": {
      "description": "QUARTER_PI es una constante matemática de valor 0.7853982. Es un cuarto de la razón entre la circunferencia de un círculo y su diámetro. Es útil en combinación con las funciones trigonométricas sin() y cos().",
      "returns": "el objeto p5"
    },
    "TAU": {
      "description": "TAU es un alias de TWO_PI, una constante matemática de valor 6.28318530717958647693. Es el doble de la razón entre la circunferencia de un círculo y su diámetro. Es útil en combinación con las funciones trigonométricas sin() y cos().",
      "returns": "el objeto p5"
    },
    "TWO_PI": {
      "description": "TWO_PI es una constante matemática de valor 6.28318530717958647693. Es el doble de la razón entre la circunferencia de un círculo y su diámetro. Es útil en combinación con las funciones trigonométricas sin() y cos().",
      "returns": "el objeto p5"
    },
    "preload": {
      "description": "La función preload() es ejecutada antes de setup(), es usada para manejar la carga asíncrona de archivos externos. Si se define una función preload(), setup() esperará hasta que las llamadas a funciones load hayan terminado. Solo se deben incluir instrucciones de carga dentro de preload() (loadImage, loadJSON, loadFont, loadStrings, etc).",
      "returns": "el objeto p5"
    },
    "setup": {
      "description": "La función setup() es ejecutada una vez, cuando el programa empieza. Es usada para definir propiedades iniciales como amaño de la pantalla y color de fondo y para cargar medios como imágenes y tipografías cuando el programa empieza. Solo puede haber una función setup() en cada programa y no debe ser llamada después de su ejecución inicial. Nota: las variables declaradas dentro de setup() no son accesibles dentro de otras funciones, como draw().",
      "returns": "el objeto p5"
    },
    "draw": {
      "description": "La función draw() es ejecutada después de setup(), y ejecuta contínuamente las líneas de código dentro de su bloque hasta que el programa es detenido o se ejecuta la función noLoop(). Notar que si noLoop() es ejecutada dentro de setup(), draw() igualmente será ejecutado una vez antes de parar. La función draw() es ejecutada automáticamente y nunca debiera ser ejecutada explícitamente. Siempre debería ser controlada con noLoop(), redraw() y loop(). Después de que noLoop() detiene la ejecución del código dentro de draw(), redraw() causa que el código dentro de draw() se ejecute una vez, y loop() causa que el código dentro de draw() siga ejecutándose de forma continua. El número de veces que draw() se ejecuta por segundo puede ser controlado con la función frameRate(). Solo puede haber una función draw() en cada bosquejo, y draw() solo debe existir si quieres que el código corra de forma continua, o para procesar eventos como mousePressed(). Algunas veces, podrías querer ejecutar una función draw() vacía, como se mostró en el ejemplo más arriba. Es importante notar que el sistema de coordenadas de dibujo será reiniciado al principio de cada ejecución de la función draw(). Si cualquier transformación es hecha dentro de draw() (por ejemplo: escalar, rotar, trasladar), sus efectos serán anulados al principio de cada ejecución de draw(), así que las transformaciones no se acumulan en el tiempo. Por el otro lado, el estilo aplicado (color de relleno, color de trazado) sí se mantendrá en efecto. ",
      "returns": "el objeto p5"
    },
    "remove": {
      "description": "Remueve el bosquejo de p5 completamente. Esto removerá el lienzo y cualquier otro elemento creado por p5.js. También detendrá el bucle de dibujo y desvinculará cualquier propiedad o método global de la ventana. Dejará una variable p5 en caso que quieras crear un nuevo bosquejo p5. Si quieres, puedes definir p5 = null para borrar esta variable.",
      "returns": "el objeto p5"
    },
    "noLoop": {
      "description": "Detiene la ejecución continua del código de draw() de p5.js. Si se llama a la función loop(), el código dentro de draw() empieza a correr de forma continua nuevamente. Si se usa noLoop() dentro de setup(), debe ser la última línea de código dentro del bloque. Cuando se usa noLoop(), no es posible manipular o acceder a la pantalla dentro de las funciones que manejan eventos como mousePressed() o keyPressed(). En vez de eso, usa estas funciones para llamar a redraw() o loop(), que permitirán la ejecución de draw(), lo que permite el refresco correcto de la pantalla. Esto significa que cuando noLoop() ha sido ejecutado, no se sigue dibujando, y funciones como saveFrame() o loadPixels() no se pueden usar. Notar que si el bosquejo es escalado, redraw() será llamado para actualizar el bosquejo, incluso si noLoop() ha sido ejecutada. Por otro lado, el bosquejo entrará a un estado singular, hasta que loop() sea ejecutado.",
      "returns": "el objeto p5"
    },
    "loop": {
      "description": "Por defecto, p5.js repite de forma continua la función draw(), ejecutado el código dentro de su bloque. Sin embargo, el bucle de dibujo puede ser detenido llamando a la función noLoop(). En ese caso, el bucle de draw() puede ser retomado con loop().",
      "returns": "el objeto p5"
    },
    "push": {
      "description": "La función push() graba la configuración actual de estilo de dibujo, y pop() restaura esta configuración. Notar que estas funciones siempre son usadas en conjunto. Permiten cambiar las configuraciones de estilo y transformaciones y luego volver a lo que tenías. Cuando un nuevo estado es iniciado con push(), construye encima de la información actual de estilo y transformación. Las funciones push() y pop() pueden ser embebidas para proveer más control (ver el segundo ejemplo para una demostración). push() almacena información relacionada a la configuración de estado de transformación y de estulo actual, controlada por las siguientes funciones: fill(), stroke(), tint(), strokeWeight(), strokeCap(), strokeJoin(), imageMode(), rectMode(), ellipseMode(), colorMode(), textAlign(), textFont(), textMode(), textSize(), textLeading().",
      "returns": "el objeto p5"
    },
    "pop": {
      "description": "La función push() graba la configuración actual de estilo de dibujo, y pop() restaura esta configuración. Notar que estas funciones siempre son usadas en conjunto. Permiten cambiar las configuraciones de estilo y transformaciones y luego volver a lo que tenías. Cuando un nuevo estado es iniciado con push(), construye encima de la información actual de estilo y transformación. Las funciones push() y pop() pueden ser embebidas para proveer más control (ver el segundo ejemplo para una demostración). push() almacena información relacionada a la configuración de estado de transformación y de estulo actual, controlada por las siguientes funciones: fill(), stroke(), tint(), strokeWeight(), strokeCap(), strokeJoin(), imageMode(), rectMode(), ellipseMode(), colorMode(), textAlign(), textFont(), textMode(), textSize(), textLeading()."
    },
    "redraw": {
      "description": "Ejecuta una vez el código dentro de la función draw(). Esta función permite al programa actualizar la ventana mostrada solamente cuando es necesario, por ejemplo, cuando un evento registrado por mousePressed() o keyPressed() ocurre. En la estructura de un programa, solo hace sentido llamar a redraw() dentro de eventos como mousePressed(). Esto es porque redraw() no hace que draw() se ejecute de forma inmediata (solo define una indicación de que se necesita un refresco). La función redraw() no funciona de forma correcta cuando se llama dentro de la función draw(). Para habilitar y deshabilitar animaciones, usa las funcioens loop() y noLoop(). Adicionalmente, puedes definir el número de veces que se dibuja por cada llamada a este método. Para esto, añade un entero como parámetro único a la función, que señale cuántas veces se requiere dibujar.",
      "params": ["Entero: redibuja n-veces. Por defecto el valor es 1"],
      "returns": "el objeto p5"
    },
    "print": {
      "description": "La función print() escribe en la consola del navegador. Esta función es a menudo de ayuda para observar los datos que un programa está produciendo. Esta función crea una nueva línea de texto por cada ejecución de la función. Elementos individuales pueden ser separados por comillas ('') y unidos con el operador de adición (+). Aunque print() es similar a console.log(), no llama a console.log() directamente, para simular una manera más simple de entender el comportamiento del programa. Por esto mismo, es más lento. Para resultados más rápidos, usar directamente console.log().",
      "params": ["Cualquiera: cualquier combinación de número, string, objeto, boolean o arreglo a imprimir"],
      "returns": "el objeto p5"
    },
    "frameCount": {
      "description": "La variable de sistema frameCount contiene el número de cuadros (frames) que se han mostrado desde que el programa empezó a ejecutarse. Dentro de setup() el valor es 0, después de la primera iteración de draw() es 1, etc.",
      "returns": "el objeto p5"
    },
    "focused": {
      "description": "Confirma si la ventana de un programa de p5.js está en foco, lo que significa que el bosquejo aceptará entradas desde el ratón o teclado. Esta variable es verdadera (true) si la ventana está en foco y falsa (false) si no.",
      "returns": "el objeto p5"
    },
    "cursor": {
      "description" : "Define el cursor como un símbolo predeterminado o una imagen, o hace el cursor visible si es que estaba escondido. Si estás tratando de asignar una imagen al cursor, el tamaño recomendado es 16x16 o 32x32 pixeles. No es posible cargar una imagen al cursor si estás exportando tu programa a la Web, y no todos los modos funcionan con todos los navegadores. Los valores de los parámetros x e y deben ser menores a la dimensión de la imagen.",
      "params": ["Número|Constante: puede ser ARROW, CROSS, HAND, MOVE, TEXT, o WAIT, o la dirección de una imagen",
      "Número: el punto activo horizontal del cursor",
      "Número: el punto activo vertical del cursor"],
      "returns": "el objeto p5"
    },
    "frameRate": {
      "description": "Especifica el número de cuadros mostrados por segundo. Por ejemplo, la llamada a la función frameRate(30), tratará de refrescar 30 veces por segundo. Si el procesador no es lo suficientemente rápido para mantener la tasa especificada, la tasa de cuadros por segundo no será lograda. Definir la tasa de cuadros por segundo dentro de setup() es lo recomendable. La tasa por defecto es de 60 veces por segundo. Esto es lo mismo que setFrameRate(val). Llamar a la función frameRate() sin argumentos retorna la tasa actual. Esto es lo mismo que getFrameRate(). Llamar a la función frameRate() con arugmentos que no son de tipo número o no son positivos también retornarán la tasa actual.",
      "params": ["Número: número de cuadros a ser mostrados cada segundo."],
      "returns": "la tasa de cuadros por segundo (frameRate) actual"
    },
    "noCursor": {
      "description": "Esconde el cursor.",
      "returns": "el objeto p5"
    },

    "displayWidth": {
      "description": "Variable de sistema que almacena el ancho de la pantalla mostrada. Esto es usado para correr un programa a pantalla completa en cualquier dimensión de pantalla.",
      "returns": "el objeto p5"
    },
    "displayHeight": {
      "description": "Variable de sistema que almacena la altura de la pantalla mostrada. Esto es usado para correr un programa a pantalla completa en cualquier dimensión de pantalla.",
      "returns": "el objeto p5"
    },
    "windowWidth": {
      "description": "Variable de sistema que almacena el ancho interior de la ventana del navegador, equivale a window.innerWidth.",
      "returns": "el objeto p5"
    },
    "windowHeight": {
      "description": "Variable de sistema que almacena la altura interior de la ventana del navegador, equivale a window.innerHeight.",
      "returns": "el objeto p5"
    },
    "windowResized": {
      "description": "La función windowResized() es llamada cada vez que la ventana del navegador cambia de tamaño. Es un buen lugar para cambiar las dimensiones del lienzo o hacer cualquier otro ajuste necesario para acomodar las nuevas dimensiones de la ventana.",
      "returns": "el objeto p5"
    },
    "width": {
      "description": "Variable de sistema que almacena el ancho del lienzo dibujado. Este valor es definido por el primer parámetro de la función createCanvas(). Por ejemplo, la llamada a la función (320, 240) define la variable width al valor 320. El valor por defecto de ancho es de 100 si es que createCanvas() no ha sido usado en el programa.",
      "returns": "el objeto p5"
    },
    "height": {
      "description": "ariable de sistema que almacena la altura del lienzo dibujado. Este valor es definido por el primer parámetro de la función createCanvas(). Por ejemplo, la llamada a la función (320, 240) define la variable width al valor 240. El valor por defecto de ancho es de 100 si es que createCanvas() no ha sido usado en el programa.",
      "returns": "el objeto p5"
    },
    "fullscreen": {
      "description": "Si se da un argumento, define que el bosquejo esté a pantalla completa basado en el valor del argumento. Si no se da un argumento, retorna el estado actual de pantalla completa. Notar que debido a restricciones del navegador esto solo puede ser llamado con una entrada de parte del usuario, por ejemplo, cuando se presiona el ratón como en el ejemplo.",
      "params": ["Boolean: define si el bosquejo debe estar a pantalla completa o no."],
      "returns": "Boolean: estado de pantalla completa actual"
    },
    "pixelDensity": {
      "description": "Define el escalamiento de pixeles para monitores de alta densidad de pixeles. Por defecto, la densidad de pixeles es definida para calzar con la densidad del monitor, ejecuta pixelDensity() para que no sea así. Llamar a pixelDensity() sin argumentos retorna la densidad de pixeles actual del bosquejo.",
      "params": ["Número: si es que el bosquejo debe ser escalado y cuánto."],
      "returns": "Número: densidad de pixeles actual del bosquejo"
    },
    "displayDensity": {
      "description": "Retorna la densidad de pixeles del monitor actual en que el bosquejo está corriendo.",
      "returns": "Número: la densidad de pixeles actual del monitor"
    },
    "getURL": {
      "description": "Retorna la URL actual.",
      "returns": "String: URL"
    },
    "getURLPath": {
      "description": "Retorna la dirección URL como un arreglo",
      "returns": "Arreglo: los componentes de la dirección"
    },
    "getURLParams": {
      "description": "Retorna los parámetros de la URL actual como un objeto.",
      "returns": "Objeto: parámetros de la URL"
    },
    "createCanvas": {
      "description": "Crea un elemento canvas en el documento, y define sus dimensiones medidas en pixeles. Este método debe ser llamado solo una vez al comienzo de la función setup(). Llamar a la función createCanvas() más de una vez en un bosquejo puede resultar en comportamientos impredecibles. Si quieres más de un lienzo donde dibujar, debes usar la función createGraphics() (escondido por defecto, pero puede ser mostrado), Las variables de sistema width (ancho) y height (altura) son definidas por los parámetros pasados a la función. Si createCanvas() no es usado, la ventana tendrá un tamaño por defecto de 100 x 100 pixeles. Para más maneras de posicionar el lienzo, ver la sección de posición del lienzo.",
      "params": ["Número: ancho del lienzo",
      "Número: altura del lienzo",
      "Constante: P2D o WEBGL"],
      "returns": "Objeto: lienzo generado"
    },
    "resizeCanvas": {
      "description": "Redimensiona el linezo al ancho y la altura dados. El lienzo será borrado y la función draw() será llamada inmediatamente, permitiendo que el bosquejo se ajuste al nuevo lienzo",
      "returns": "el objeto p5"
    },
    "noCanvas": {
      "description": "Remueve el lienzo por defecto para un bosquejo de p5 que no requiere un lienzo.",
      "returns": "el objeto p5"
    },
    "createGraphics": {
      "description": "Crea y retorna un nuevo objeto p5.Renderer. Usa esta clase si necesitas dibujar fuera de pantalla en un buffer gráfico. Los dos parámetros definen el ancho y la altura en pixeles.",
      "params": ["Número: ancho del buffer gráfico fuera de pantalla",
      "Número: altura del buffer gráfico fuera de pantalla",
      "Constante: P2D o WEBGL, si no se define es P2D por defecto"],
      "returns": "buffer gráfico fuera de pantalla"
    },
    "blendMode": {
      "description": "Combina los pixeles en la ventana según el modo definido. Existen distintas maneras de combinar los pixeles de la fuente (A) con los ya existentes en la pantalla mostrada (B). TODO",
      "params": ["Constante: modo de combinar del lienzo"],
      "returns": "el objeto p5"
    },
    "applyMatrix": {
      "description": "Multiplica la matriz actual por la especificada según los parámetros. Esto es muy lento porque tratará de calcular el inverso de la transformada, así que evítalo cuando sea posible",
      "params": ["Número: números que definen la matriz 3x2 a multiplicar",
      "Número: números que definen la matriz 3x2 a multiplicar",
      "Número: números que definen la matriz 3x2 a multiplicar",
      "Número: números que definen la matriz 3x2 a multiplicar",
      "Número: números que definen la matriz 3x2 a multiplicar",
      "Número: números que definen la matriz 3x2 a multiplicar"],
      "returns": "el objeto p5"
    },
    "resetMatrix": {
      "description": "Reemplaza la matriz actual con la matriz identidad",
      "returns": "el objeto p5"
    },
    "rotate": {
      "description": "Rota una figura según el monto especificado por el parámetro ángulo. Esta función toma en cuenta el modo de ángulo definido por angleMode(), así que los ángulos pueden ser ingresados en radianes o grados. Los objetos son siempre rotados según su posición relativa al origen y los números positivos rotan en la dirección de las manecillas del reloj. Las transformaciones se aplican a todo lo que ocurre de forma posterior y las subsecuentes llamadas a la función acumulan el efecto. Por ejemplo, llamar a la función rotate(HALF_PI) y luego rotate(HALF_PI) equivale a una llamada a rotate(PI). Todas las transformaciones son anuladas cuando la función draw() comienza nuevamente. Técnicamente, rotate() multiplica la matriz de transformación actual por una matriz de rotación. Esta función puede ser controlada además con las funciones push() y pop().",
      "params": ["Ángulo: el ángulo de rotación, especificado en radianes o grados, dependiendo de angleMode()",
      "Número: ángulo en radianes",
      "p5.Vector|Arreglo: eje sobre el que se rota"],
      "returns": "el objeto p5"
    },
    "rotateX": {
      "description": "Rota en torno al eje X",
      "params": ["Número: ángulo en radianes"],
      "returns": "el objeto p5"
    },
    "rotateY": {
      "description": "Rota en torno al eje Y",
      "params": ["Número: ángulo en radianes"],
      "returns": "el objeto p5"
    },
    "rotateZ": {
      "description": "Rota en torno al eje Z,. Sólo disponible en el modo WEBGL.",
      "params": ["Número: ángulo en radianes"],
      "returns": "el objeto p5"
    },
    "scale": {
      "description": "Aumenta o decrementa el tamaño de una figura por medio de expandir o contraer sus vértices. Los objetos siempre escalan desde su origen relativo al sistema de coordenadas. Los valores de escalamiento son porcentajes decimales. Por ejemplo, la llamada a la función scale(2.0) aumenta la dimensión de una figura en un 200%. Las transformaciones se aplican a todo lo que ocurre después y llamadas subsecuentes a la función multiplican el efecto. Por ejemplo, llamar a scale(2.0) y luego a scale(1.5) equivale a llamar a scale(3.0). Si la función scale() es llamad dentro de draw(), la transformación es anulada cuando el bucle empieza nuevamente. El uso de esta función con el parámetro z está solo disponible en el modo WEBGL. Esta función puede también ser controlada con las funciones push() y pop().",
      "params": ["Número | p5.Vector| Arreglo: porcentaje a escalar del objeto, o porcentaje a esacalar del objeto en el eje x si se dan múltiples argumentos",
      "Número: porcentaje a escalar el objeto en el eje y",
      "Número: porcentaje a escalar el objeto en el eje z (sólo en modo WEBGL)"],
      "returns": "el objeto p5"
    },
    "shearX": {
      "description": "Corta la figura en torno al eje x según el monto especificado por el parámetro ángulo. Los ángulos deben ser especificados según el modo actual de ángulo angleMode(). Los objetos son siempre cortados según su posición relativa al origen y los números positivos cortan los objetos en la dirección de las manecillas del reloj. Las transformaciones aplican a todo lo que ocurre después y llamadas posteriores a la misma función acumulan el efecto. Por ejemplo, llamar a shearX(PI/2) y luego a shearX(PI/2) equivale a llamar a shearX(PI). Si shearX() es llamado dentro de draw(), la transformación es anulada cuando el bucle empieza nuevamente. Técnicamente, shearX() multiplica la matriz de transformación actual por una matriz de rotación. La función puede ser controlada con las funciones push() y pop().",
      "params": ["Número: ángulo de corte especificado en radianes o grados, dependiendo del modo de ángulo actual angleMode()"],
      "returns": "el objeto p5"
    },
    "shearY": {

        "description": "Corta la figura en torno al eje y según el monto especificado por el parámetro ángulo. Los ángulos deben ser especificados según el modo actual de ángulo angleMode(). Los objetos son siempre cortados según su posición relativa al origen y los números positivos cortan los objetos en la dirección de las manecillas del reloj. Las transformaciones aplican a todo lo que ocurre después y llamadas posteriores a la misma función acumulan el efecto. Por ejemplo, llamar a shearY(PI/2) y luego a shearY(PI/2) equivale a llamar a shearY(PI). Si shearY() es llamado dentro de draw(), la transformación es anulada cuando el bucle empieza nuevamente. Técnicamente, shearY() multiplica la matriz de transformación actual por una matriz de rotación. La función puede ser controlada con las funciones push() y pop().",
        "params": ["Número: ángulo de corte especificado en radianes o grados, dependiendo del modo de ángulo actual angleMode()"],
        "returns": "el objeto p5"
    },
    "translate": {
      "description": "Especifica una cantidad a desplazar los objetos dentro de la ventana mostrada. El parámetro x especifica la traslación de izquierda a derecha, el parámetro y especifica la traslación de arriba a abajo. Las transformaciones son acumulativas y aplican a todo lo que ocurre después y llamadas posteriores a la misma función acumulan el efecto. Por ejemplo, llamar a translate(50, 0) y luego a translate(20, 0) equivale a llamar a translate(70, 0). Si translate() es llamado dentro de draw(), la transformación es anulada cada vez que el bucle empieza nuevamente. Esta función peude ser controlada con las funciones push() y pop().",
      "params": ["Número: traslación izquierda-derecha",
      "Número: traslación arriba-abajo",
      "Número: traslación adelante-atrás (solo en modo WEBGL)"],
      "returns": "el objeto p5"
    },
    "deviceOrientation": {
      "description": "La variable de sistema deviceOrientation siempre contiene la orientación del dispositivo. El valor de esta variable será o landscape (paisaje) o portrait (retrato). Si la información no está disponible, su valor será undefined.",
      "returns": "el objeto p5"
    },
    "accelerationX": {
      "description": "La variable de sistema accelerationX siempré contiene la aceleración del dispositivo en el eje X. El valor es representado en unidades de metros por segundo al cuadrado.",
      "returns": "el objeto p5"
    },
    "accelerationY": {
      "description": "La variable de sistema accelerationX siempré contiene la aceleración del dispositivo en el eje Y. El valor es representado en unidades de metros por segundo al cuadrado.",
      "returns": "el objeto p5"
    },
    "accelerationZ": {
      "description": "La variable de sistema accelerationX siempré contiene la aceleración del dispositivo en el eje Z. El valor es representado en unidades de metros por segundo al cuadrado.",
      "returns": "el objeto p5"
    },
    "pAccelerationX": {
      "description": "La variable de sistema pAccelerationX siempré contiene la aceleración del dispositivo en el eje X, del cuadro anterior al cuadro actual. El valor es representado en unidades de metros por segundo al cuadrado.",
      "returns": "el objeto p5"
    },
    "pAccelerationY": {
      "description": "La variable de sistema pAccelerationY siempré contiene la aceleración del dispositivo en el eje Y, del cuadro anterior al cuadro actual. El valor es representado en unidades de metros por segundo al cuadrado.",
      "returns": "el objeto p5"
    },
    "pAccelerationZ": {
      "description": "La variable de sistema pAccelerationZ siempré contiene la aceleración del dispositivo en el eje Z, del cuadro anterior al cuadro actual. El valor es representado en unidades de metros por segundo al cuadrado.",
      "returns": "el objeto p5"
    },
    "rotationX": {
      "description": "La variable de sistema rotationX siempre contiene la rotación del dispositivo en el eje x. El valor está representado entre 0 y  +/-180 grados. Nota: el orden en que las rotaciones son llamadas es importante, por ejemplo, si se usan juntas, deben ser llamadas en el orden Z-X-Y, en caso contrario podría haber un comportamiento errado.",
      "returns": "el objeto p5"
    },
    "rotationY": {
      "description": "La variable de sistema rotationX siempre contiene la rotación del dispositivo en el eje x. El valor está representado entre 0 y  +/-180 grados. Nota: el orden en que las rotaciones son llamadas es importante, por ejemplo, si se usan juntas, deben ser llamadas en el orden Z-X-Y, en caso contrario podría haber un comportamiento errado.",
      "returns": "el objeto p5"
    },
    "rotationZ": {
      "description": "La variable de sistema rotationX siempre contiene la rotación del dispositivo en el eje y. El valor está representado entre 0 y  360 grados. A diferencia de rotationX y rotationY, esta variable está solo disponible en dispositivos equipados con una brújula interna. Nota: el orden en que las rotaciones son llamadas es importante, por ejemplo, si se usan juntas, deben ser llamadas en el orden Z-X-Y, en caso contrario podría haber un comportamiento errado.",
      "returns": "el objeto p5"
    },
    "pRotationX": {
      "description": "La variable de sistema pRotationX siempre contiene la rotación del dispositivo en el eje x, en el cuadro anterior al actual. El valor está representado entre 0 y  +/-180 grados. pRotationX puede ser usado en conjunto con rotationX para determinar la dirección de rotación del dispositivo a lo largo del eje x.",
      "returns": "el objeto p5"
    },
    "pRotationY": {
      "description": "La variable de sistema pRotationY siempre contiene la rotación del dispositivo en el eje x, en el cuadro anterior al actual. El valor está representado entre 0 y  +/-90 grados. pRotationY puede ser usado en conjunto con rotationY para determinar la dirección de rotación del dispositivo a lo largo del eje y.",
      "returns": "el objeto p5"
    },
    "pRotationZ": {
      "description": "La variable de sistema pRotationZ siempre contiene la rotación del dispositivo en el eje z, en el cuadro anterior al actual. El valor está representado entre 0 y 359 grados. pRotationZ puede ser usado en conjunto con rotationZ para determinar la dirección de rotación del dispositivo a lo largo del eje z.",
      "returns": "el objeto p5"
    },
    "setMoveThreshold": {
      "description": "La función setMoveThreshold() es usada para definir el umbral para detectar movimiento de la función deviceMoved(). El valor umbral por defecto es 0.5",
      "params": ["Número: el valor umbral"],
      "returns": "el objeto p5"
    },
    "setShakeThreshold": {
      "description": "La función setShakeThreshold() es usada para definir el umbral para detectar agitamiento de la función deviceShaken(). El valor umbral por defecto es 30.",
      "params": ["Número: el valor umbral"],
      "returns": "el objeto p5"
    },
    "deviceMoved": {
      "description": "La función deviceMoved() es llamada cuando el dispositivo es movido en una cantidad mayor al valor umbral en el eje X, Y o Z. El valor umbral por defecto es 0.5",
      "returns": "el objeto p5"
    },
    "deviceTurned": {
      "description": "La función deviceTurned() es llamada cuando el dispositivo es girado en más de 90 grados de modo continuo. El eje que gatilla la función deviceTurned() es almacenado en la variable turnAxis. El método deviceTurned() puede ser restringido para gatillar en cualquier eje: X, Y o Z, comparando la variable turnAxis con X, Y o Z.",
      "returns": "el objeto p5"
    },
    "deviceShaken": {
      "description": "La función deviceShaken() es llamada cuando la aceleración total de los cambios de accelerationX y accelerationY son mayores al valor umbral. El valor umbral por defecto es 30",
      "returns": "el objeto p5"
    },
    "keyIsPressed": {
      "description": "La variable boolean de sistema keyIsPressed es verdadera (true) cuando cualquier tecla es presionada y falsa (false) si no hay ninguna tecla presionada",
      "returns": "el objeto p5"
    },
    "key": {
      "description": "La variable de sistema key siempre contiene el valor más reciente de la tecla del teclado presionada. Para tener los mejores resultados, es mejor usarla dentro de la función keyTyped(). Para teclas sin valor ASCII, usa la variable keyCode ",
      "returns": "el objeto p5"
    },
    "keyCode": {
      "description": "La variable keyCode es usada para detectar teclas especiales, como BACKSPACE, DELETE, ENTER, RETURN, ESCAPE, SHIFT, CONTROL, OPTION, ALT, UP_ARROW, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW. También puedes revisar las teclas especiales buscando el código keyCode de cualquier tecla en internet.",
      "returns": "el objeto p5"
    },
    "keyPressed": {
      "description": "La función keyPressed() es llamada una vez cada vez que una tecla es presionada. El código keyCode de la tecla presionada es almacenado en la variable keyCode. Para las teclas sin valor ASCII, usa la variable keyCode.  Puedes comprobar si la variable keyCode es igual a BACKSPACE, DELETE, ENTER, RETURN, ESCAPE, SHIFT, CONTROL, OPTION, ALT, UP_ARROW, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW. Para las teclas con valor ASCII que son presionadas, el valor es almacenado en la variable key. Sin embargo, no distingue entre letras mayúsculas y minúsculas. Por esta razón, es recomendable usar la función keyTyped() para leer la variable key, que sí distingue entre mayúsculas y minúsculas. Por la forma en que los sistemas operativos manejan la repetición de teclas, mantener presionada una tecla puede causar múltiples llamadas a keyTyped() (y también keyReleased()). La tasa de repetición es definida por el sistema operativo y según cómo cada computador está configurado. Los navegadores tienen distintos comportamientos por defecto asociados a distintos eventos gatillados por teclas. Para prevenir cualquier comportamiento por defecto para este evento, añade return false al final de este método.",
      "returns": "el objeto p5"
    },
    "keyReleased": {
      "description": "La función keyReleased() es llamada una vez cada vez que una tecla es soltada. Ver key y keyCode para más información. Los navegadores tienen distintos comportamientos por defecto asociados a distintos eventos gatillados por teclas. Para prevenir cualquier comportamiento por defecto para este evento, añade return false al final de este método.",
      "returns": "el objeto p5"
    },
    "keyTyped": {
      "description": "la función keyTyped es llamada cava vez que una tecla es presionada, excepto cuando son presionadas la steclas de acción como Ctrl, Shift y Alt, que son ignoradas. La tecla presionada más reciente será almacenada en la variable key. Por la forma en que los sistemas operativos manejan la repetición de teclas, mantener presionada una tecla puede causar múltiples llamadas a keyTyped() (y también keyReleased()). La tasa de repetición es definida por el sistema operativo y según cómo cada computador está configurado. Los navegadores tienen distintos comportamientos por defecto asociados a distintos eventos gatillados por teclas. Para prevenir cualquier comportamiento por defecto para este evento, añade return false al final de este método.",
      "params": ["Número: el valor umbral"],
      "returns": "el objeto p5"
    },
    "keyIsDown": {
      "description": "La función keyIsDown() comprueba si la tecla está presionada. Puede ser usada si tienes un objeto que se mueve, y quieres que varias teclas sean capaces de afectar este comportamiento de manera simultánea, como cuando mueves una imagen de forma diagonal. Puedes ingresar cualquier número representando el código de tecla keyCode de la tecla, o usar cualquier de los nombres de la variable keyCode.",
      "params": ["Número: la tecla a buscar"],
      "returns": "el objeto p5"
    },
    "mouseX": {
      "description": "La variable de sistema mouseX siempre contiene la posición horizontal actual del ratón, relativa al origen (0, 0) del lienzo.",
      "returns": "el objeto p5"
    },
    "mouseY": {
      "description": "La variable de sistema mouseY siempre contiene la posición vertical actual del ratón, relativa al origen (0, 0) del lienzo.",
      "returns": "el objeto p5"
    },
    "pmouseX": {
        "description": "La variable de sistema pmouseX siempre contiene la posición horizontal actual del ratón, en el cuadro anterior al actual, relativa al origen (0, 0) del lienzo.",
        "returns": "el objeto p5"
    },
    "pmouseY": {
      "description": "La variable de sistema pmouseY siempre contiene la posición vertical actual del ratón, en el cuadro anterior al actual, relativa al origen (0, 0) del lienzo.",
      "returns": "el objeto p5"
    },
    "winMouseX": {
      "description": "La variable de sistema winMouseX siempre contiene la posición horizontal actual del ratón, relativa al origen (0, 0) de la ventana del navegador.",
      "returns": "el objeto p5"
    },
    "winMouseY": {
      "description": "La variable de sistema winMouseY siempre contiene la posición vertical actual del ratón, relativa al origen (0, 0) de la ventana del navegador.",
      "returns": "el objeto p5"
    },
    "pwinMouseX": {
      "description": "La variable de sistema pwinMouseX siempre contiene la posición horizontal actual del ratón, en el cuadro anterior al actual, relativa al origen (0, 0) de la ventana del navegador.",
      "returns": "el objeto p5"
    },
    "pwinMouseY": {
      "description": "La variable de sistema pwinMouseY siempre contiene la posición vertical actual del ratón, en el cuadro anterior al actual, relativa al origen (0, 0) de la ventana del navegador.",
      "returns": "el objeto p5"
    },
    "mouseButton": {
      "description": "P5.js automáticamente rastrea si el botón del ratón está presionado y cuál botón está presionado. El valor de la variable de sistema mouseButton es o LEFT, RIGHT o CENTER dependiendo de cual fue el último botón presionado. Advertencia: diferentes navegadores pueden diferir.",
      "returns": "el objeto p5"
    },
    "mouseIsPressed": {
      "description": "La variable boolean de sistema mouseIsPressed es verdadera (true) si el ratón está siendo presionado, y falsa (false) en caso contrario.",
      "returns": "el objeto p5"
    },
    "mouseMoved": {
      "description": "La función mouseMoved() es llamada cada vez que el ratón se mueve y un botón del ratón no está siendo presionado. Los navegadores pueden tener comportamientos por defecto asociados a distintos eventos del ratón. Para prevenir cualquier comportamiento por defecto, añade return false como última línea de este método.",
      "returns": "el objeto p5"
    },
    "mouseDragged": {
      "description": "La función mouseDragged() es llamada cada vez que el ratón se mueve y un botón del ratón está siendo presionado. Los navegadores pueden tener comportamientos por defecto asociados a distintos eventos del ratón. Para prevenir cualquier comportamiento por defecto, añade return false como última línea de este método.",
      "returns": "el objeto p5"
    },
    "mousePressed": {
      "description": "La función mousePressed() es llamada cada vez que un botón del ratón está siendo presionado. La variable mouseButton (ver la referencia) puede ser usada para determinar cual botón está siendo presionado. Si no se define una función mousePressed(), la función touchStarted() será llamada en su reemplazo, si es que está definida. Los navegadores pueden tener comportamientos por defecto asociados a distintos eventos del ratón. Para prevenir cualquier comportamiento por defecto, añade return false como última línea de este método.",
      "returns": "el objeto p5"
    },
    "mouseReleased": {
      "description": "La función mouseReleased() es llamada cada vez que un botón del ratón es soltado. Si no se define una función mouseReleased(), la función touchEnded() será llamada en su reemplazo, si es que está definida. Los navegadores pueden tener comportamientos por defecto asociados a distintos eventos del ratón. Para prevenir cualquier comportamiento por defecto, añade return false como última línea de este método.",
      "returns": "el objeto p5"
    },
    "mouseClicked": {
      "description": "La función mouseClicked() es llamada cada vez que un botón del ratón es presionado y luego soltado. Los navegadores pueden tener comportamientos por defecto asociados a distintos eventos del ratón. Para prevenir cualquier comportamiento por defecto, añade return false como última línea de este método.",
      "returns": "el objeto p5"
    },
    "mouseWheel": {
      "description": "La función mouseWheel() es llamada cada vez que se detecta un evento de rueda de ratón vertical, ya sea gatillado por un ratón o por un touchpad. La propiedad event.delta retorna el monto que el ratón ha avanzado. Estos valores pueden ser positivos o negativos, dependiendo de la dirección de navegación (en OS X con natural scrolling, los signos son invertidos).  Los navegadores pueden tener comportamientos por defecto asociados a distintos eventos del ratón. Para prevenir cualquier comportamiento por defecto, añade return false como última línea de este método. Debido al soporte actual del evento wheel en Safari, la función podría solo funcionar si return false es incluido cuando se usa Safari.",
      "returns": "el objeto p5"
    },
    "touchX": {
      "description": "La variable de sistema touchX siempre contiene la posición horizontal de un dedo, relativo al origen (0, 0) del lienzo. Esto funciona mejor con interacciones de un dedo a la vez. Para interacciones multi-dedo, usar el arreglo touches[]",
      "returns": "el objeto p5"
    },
    "touchY": {
      "description": "La variable de sistema touchY siempre contiene la posición vertical de un dedo, relativo al origen (0, 0) del lienzo. Esto funciona mejor con interacciones de un dedo a la vez. Para interacciones multi-dedo, usar el arreglo touches[]",
      "returns": "el objeto p5"
    },
    "ptouchX": {
      "description": "La variable de sistema ptouchX siempre contiene la posición horizontal de un dedo, relativo al origen (0, 0) del lienzo, en el cuadro anterior al actual. Esto funciona mejor con interacciones de un dedo a la vez. Para interacciones multi-dedo, usar el arreglo touches[]",
      "returns": "el objeto p5"
    },
    "ptouchY": {
      "description": "La variable de sistema ptouchY siempre contiene la posición vertical de un dedo, relativo al origen (0, 0) del lienzo, en el cuadro anterior al actual. Esto funciona mejor con interacciones de un dedo a la vez. Para interacciones multi-dedo, usar el arreglo touches[]",
      "returns": "el objeto p5"
    },
    "winTouchX": {
      "description": "La variable de sistema winTouchX siempre contiene la posición horizontal de un dedo, relativo al origen (0, 0) de la ventana.",
      "returns": "el objeto p5"
    },
    "winTouchY": {
      "description": "La variable de sistema winTouchY siempre contiene la posición vertical de un dedo, relativo al origen (0, 0) de la ventana.",
      "returns": "el objeto p5"
    },
    "pwinTouchX": {
      "description": "La variable de sistema pwinTouchX siempre contiene la posición horizontal de un dedo, relativo al origen (0, 0) de la ventana, en el cuadro anterior al actual.",
      "returns": "el objeto p5"
    },
    "pwinTouchY": {
      "description": "La variable de sistema pwinTouchY siempre contiene la posición verticañ de un dedo, relativo al origen (0, 0) de la ventana, en el cuadro anterior al actual.",
      "returns": "el objeto p5"
    },
    "touches[]": {
      "description": "La variable de sistema touches[] contiene un arreglo de las posiciones de todos los puntos de toque actuales, relativos al origen (0, 0) del lienzo, y también identificadores para cada toque mientras se mueve. Cada elemento en el arreglo es un objeto con las propiedas x, y e identidad.",
      "returns": "el objeto p5"
    },
    "touchIsDown": {
      "description": "La variable boolean de sistema touchIsDown es verdadera (true) si en la pantalla hay un toque y falsa (false) si no.",
      "returns": "el objeto p5"
    },
    "touchStarted": {
      "description": "La función touchStarted() es llamada una vez, cada vez que un toque nuevo es registrado. Si la función touchStarted() no ha sido definida, la función mouseIsPressed() será llamada en su lugar, si es que está definida. Los navegadores tienen distintos comportamientos por defecto asociados a distintos eventos gatillados por toque. Para prevenir cualquier comportamiento por defecto para este evento, añade return false al final de este método.",
      "returns": "el objeto p5"
    },
    "touchMoved": {
      "description": "La función touchStarted() es llamada una vez, cada vez que es registrado el movimiento de un toque. Si la función touchMoved() no ha sido definida, la función mouseDragged() será llamada en su lugar, si es que está definida. Los navegadores tienen distintos comportamientos por defecto asociados a distintos eventos gatillados por toque. Para prevenir cualquier comportamiento por defecto para este evento, añade return false al final de este método.",
      "returns": "el objeto p5"
    },
    "touchEnded": {
      "description": "La función touchEnded() es llamada una vez, cada vez que un toque finaliza. Si la función touchEnded() no ha sido definida, la función mouseReleased() será llamada en su lugar, si es que está definida. Los navegadores tienen distintos comportamientos por defecto asociados a distintos eventos gatillados por toque. Para prevenir cualquier comportamiento por defecto para este evento, añade return false al final de este método.",
      "returns": "el objeto p5"
    },
    "createImage": {
      "description": "Crea una nueva p5.Image (el tipo de datos para almacenar imágenes). Esto provee un nuevo buffer de pixeles para jugar. Define el tamaño del buffer con los parámetros de ancho y altuar. .pixels da acceso a un arreglo conteniendo los valores de todos los pixeles en la ventana mostrada. Estos valores son números. Este arreglo es del tamaño (incluyendo un factor apropiado de pixelDensity) de la ventana mostrada x4, representando los valroes R, G, B, A en orden para cada pixel., moviendo de izquierda a derecha en cada fila, y luego bajando de columna. Ver .pixels para mayor información. Podría ser más simple usar set() y get(). Antes de acceder a los pixeles de una imagen, los datos deben ser cargados con la función loadPixels(). Después de que el arreglo de datos ha sido modificado, la función updatePixels() debe ejecutarse para actualizar los cambios.",
      "params": ["Entero: ancho en pixeles",
      "Entero: altura en pixeles"],
      "returns": "el objeto p5"
    },
    "saveCanvas": {
      "description": "Graba el lienzo actual como una imagen. En Safari, esto abrirá la imagen en la ventana y el usuario deberá proveer su propio nombre de archivo. Otros navegadores o grabarán el archivo de inmediato, o abrirán una ventana de diálogo.",
      "params": ["Canvas seleccionado: una variable representando un canvas HTML5 específico (opcional)",
      "String",
      "String: jpg o png"],
      "returns": "el objeto p5"
    },
    "saveFrames": {
      "description": "Captura una secuencia de cuadros que pueden ser usados para crear una película. Acepta una función callback. Por ejemplo, puedes querer mandar los cuadros a un servidor donde pueden ser almacenados o convertidos en una película. Si no se provee una función callback, el navegador abrirá varios diálogos tratando de descargar todas las imágenes que han sido creadas. Con una función callback provista, los datos de imagen no son grabados por defecto, sino que son pasados como argumento a la función callback como un arreglo de objetos, con el tamaño del arreglo siendo igual al número total de cuadros.",
      "params": ["String: ",
      "String: jpg o png",
      "Número: duración en segundos para grabar los cuadros",
      "Número: tasa de cuadros por segundo a grabar",
      "Función: una función callback que será ejecutada para manejar los datos de imagen. Esta función deberá aceptar un arreglo como argumento. El arreglo contendrá el número especificado de cuadros como objetos. Cada objeto tiene tres propiedades: datos de imagen imageData, nombre del archivo y extensión"],
      "returns": "el objeto p5"
    }


  },
  "p5.Image": {
    "loadPixels": {
      "description": "blah",
      "params": ["Numero: blah",
                 "Numero: blah"],
      "returns": "TODO"
    }
  },
  "p5.Element": {
    "description": "Clase base para todos los elementos añadidos al bosuqejo, incluyendo lienzo, buffers de gráficas, y otros elementos HTML. Los métodos en azul están incluidos en la funcionalidad base, los métodos en marrón son añadidos con la biblioteca p5.dom. No se ejecutan directamente, pero los objetos p5.Element son creados llamando a las funciones createCanvas(), createGraphics(), o en la biblioteca p5.dom, createDiv, createImg, createInput, etc.",
    "params": ["String: node DOM envolvente.",
    "Objeto: puntero a instancia p5."],
    "returns": "TODO"
  }
}
