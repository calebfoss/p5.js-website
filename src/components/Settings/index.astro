---
import { defaultLocale, supportedLocales } from "@/src/i18n/const";
import {
  getCurrentLocale,
  removeLocalePrefix,
  useTranslations,
} from "@/src/i18n/utils";
import { AccessibilitySettings } from "@components/AccessibilitySettings/";
import SearchForm from "@components/SearchForm/index.astro";
import { LocaleSelect } from "@components/LocaleSelect";
import styles from "./styles.module.scss";

const currentLocation = removeLocalePrefix(Astro.url.pathname);
const currentLocale = getCurrentLocale(Astro.url.pathname);
// Generate the correct URL for all supported locales
const localeOptions = supportedLocales.map((locale) => {
  // No url prefix for the default locale
  const targetLocale = locale === defaultLocale ? "" : locale;
  return {
    locale,
    // displays the language associated with a
    // locale code in its own language
    label: new Intl.DisplayNames([locale], { type: "language" }).of(locale),
    // The url for the default locale does not need a leading slash
    url: `${locale === defaultLocale ? "" : "/"}${targetLocale}${currentLocation}`,
  };
});

// move the current locale to the front of the array
localeOptions.sort((a, b) => {
  if (a.locale === currentLocale) {
    return -1;
  }
  if (b.locale === currentLocale) {
    return 1;
  }
  return 0;
});

const localeOptionProps = localeOptions.map(({ locale, label, url }) => ({
  value: url,
  label,
  id: locale,
}));

const t = await useTranslations(currentLocale);

const a11ySettingsProps = [
  {
    value: "dark-theme",
    label: t("Dark Mode"),
  },
  {
    value: "monochrome-theme",
    label: t("Monochrome Mode"),
  },
  {
    value: "show-alt-text",
    label: t("View Alt Text"),
  },
  {
    value: "reduced-motion",
    label: t("Reduced Motion"),
  },
];
---

<div id="settings-placeholder" class={styles.placeholder}></div>
<div id="settings-hitbox" class={styles.hitbox}></div>
<div id="settings-container" class={`${styles.container} settings`}>
  <div class={styles.localeselect}>
    <LocaleSelect
      locale={currentLocale}
      options={localeOptionProps}
      client:load
    />
  </div>
  <div class={styles.a11yselect}>
    <AccessibilitySettings client:load options={a11ySettingsProps} />
  </div>
  <div class={styles.searchform}>
    <SearchForm />
  </div>
</div>
<script>
  const hitBox = document.getElementById("settings-hitbox");
  const settingsContainer = document.getElementById("settings-container");
  const settingsPlaceholder = document.getElementById("settings-placeholder");
  let isHovering = false;
  let lastScrollTop = 0;
  const SCROLL_THRESHOLD = 50;
  let interactionTimeout; // Timeout for opening and closing the settings container
  let isContainerVisible = false; // Flag to track visibility of settings container
  // Observer callback to toggle isContainerVisible based on intersection with viewport
  const observerCallback = (entries) => {
    entries.forEach((entry) => {
      isContainerVisible = entry.isIntersecting;
      if (isContainerVisible) {
        console.log("Settings container is visible");
        settingsContainer.classList.remove("scrolled-outside-view");
      } else {
        console.log("Settings container is not visible");
        settingsContainer.classList.add("scrolled-outside-view");
      }
    });
  };

  // Create an observer instance.
  // This will be used to track the visibility of the settings container placeholder
  // So we can avoid opening the settings container when the top of the page is reached
  const observer = new IntersectionObserver(observerCallback);
  observer.observe(settingsPlaceholder);

  function openSettings(scroll = false) {
    if (isContainerVisible) return; // Don't open if already visible
    settingsContainer?.classList.add("open");
    if (!scroll) {
      isHovering = true;
    }
    resetInteractionTimeout();
  }

  function closeSettings() {
    clearTimeout(interactionTimeout);
    if (!isHovering) settingsContainer?.classList.remove("open");
  }

  function resetInteractionTimeout() {
    clearTimeout(interactionTimeout);
    interactionTimeout = setTimeout(closeSettings, 2000);
  }

  hitBox?.addEventListener(
    "mouseenter",
    () => !isContainerVisible && openSettings()
  );
  settingsContainer?.addEventListener(
    "mouseenter",
    () => !isContainerVisible && openSettings()
  );

  hitBox?.addEventListener("mouseleave", () => {
    isHovering = false;
    interactionTimeout = setTimeout(closeSettings, 600);
  });
  settingsContainer?.addEventListener("mouseleave", () => {
    isHovering = false;
    interactionTimeout = setTimeout(closeSettings, 600);
  });

  settingsContainer?.addEventListener("mousemove", resetInteractionTimeout);
  settingsContainer?.addEventListener("click", resetInteractionTimeout);

  // When the user scrolls up, open the settings container
  window.addEventListener(
    "scroll",
    () => {
      let currentScroll =
        window.pageYOffset || document.documentElement.scrollTop;
      if (
        lastScrollTop > currentScroll &&
        lastScrollTop - currentScroll > SCROLL_THRESHOLD &&
        !isContainerVisible // Only trigger on scroll if the container is not visible
      ) {
        openSettings(true);
      }
      lastScrollTop = currentScroll <= 0 ? 0 : currentScroll;
    },
    false
  );
</script>
