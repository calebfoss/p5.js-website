{
  "Home": "홈",
  "Download": "다운로드",
  "Start": "시작하기",
  "Reference": "레퍼런스",
  "reference-tagline": "프로세싱의 직관성에 자바스크립트의 강력함을 곱하다*",
  "reference-search": "API 검색",
  "reference-menu-home": "홈",
  "reference-menu-download": "다운로드",
  "reference-menu-get-started": "시작하기",
  "reference-menu-reference": "레퍼런스",
  "reference-menu-libraries": "라이브러리",
  "reference-menu-learn": "배우기",
  "reference-menu-examples": "예제",
  "reference-menu-books": "출판물",
  "reference-menu-community": "커뮤니티",
  "reference-menu-forum": "포럼",
  "reference-description1": "찾는 항목이 없다면, 다음의 페이지를 살펴보세요:",
  "reference-description2": " 또는 ",
  "reference-description3": "오프라인 버전의 레퍼런스는 다음 링크에서 다운받을 수 있습니다: ",
  "reference-contribute1": "잘못된 부분이나 제안사항이 있다면",
  "reference-contribute2": "언제든 알려주세요",
  "reference-error1": "오타나 버그를 발견했다면",
  "reference-error2": "관련 문서는 이곳에 있습니다: ",
  "reference-error3": "p5.js에 기여하고 싶다면, ",
  "reference-error4": "파일을 수정하고",
  "reference-error5": "에 풀 리퀘스트(pull request) 해주세요!",
  "reference-example": "예제",
  "reference-description": "설명",
  "reference-extends": "확장",
  "reference-parameters": "변수",
  "reference-syntax": "문법",
  "reference-returns": "반환",
  "footer1": "p5.js는 ",
  "footer2": "가 창안하고 협력자 커뮤니티와 함께 개발되었습니다. 지원: 프로세싱 재단 ",
  "footer3": " 과 ",
  "footer4": " 아이덴티티 및 그래픽 디자인:",
  "Libraries": "라이브러리",
  "Learn": "배우기",
  "Examples": "예제",
  "Books": "출판물",
  "Community": "커뮤니티",
  "Contribute": "함께하기",
  "Forum": "포럼",
  "h1": "레퍼런스",
  "Color": "색상",
  "Shape": "도형", 
  "Creating & Reading": "만들기 & 읽기", 
  "Setting": "설정하기", 
  "2D Primitives": "2D 기본 조형", 
  "Attributes": "설정 요소",  
  "Curves": "곡선", 
  "Vertex": "버텍스", 
  "3D Models": "3D 모델",  
  "3D Primitives": "3D 기본 조형", 
  "Constants": "상수",  
  "Structure": "구조",  
  "Environment": "환경",  
  "DOM": "DOM", 
  "Rendering": "렌더링",  
  "Transform": "변형", 
  "Data": "데이터",  
  "Dictionary": "사전",  
  "Array Functions": "배열 기능",  
  "Conversion": "변환", 
  "String Functions": "문자열 기능",  
  "Events": "이벤트",  
  "Acceleration": "가속도",  
  "Keyboard": "키보드",  
  "Mouse": "마우스", 
  "Touch": "터치", 
  "Image": "이미지",  
  "Loading & Displaying": "불러오기 & 보이기", 
  "Pixels": "픽셀",  
  "IO": "IO", 
  "Input": "입력", 
  "Output": "출력", 
  "Table": "테이블", 
  "Time & Date": "날짜 & 시간",  
  "XML": "XML", 
  "Math": "수학", 
  "Calculation": "계산",  
  "Noise": "노이즈", 
  "Trigonometry": "삼각법",  
  "Typography": "타이포그래피", 
  "Font": "폰트", 
  "Lights, Camera": "조명, 카메라",  
  "Camera": "카메라",  
  "Lights": "조명",  
  "Material": "재질(Material)", 
  "p5": {
   "alpha": {
      "description": "픽셀 배열로부터 알파값을 추출합니다.",
      "params": ["p5.Color | 숫자[] | 문자열: p5.Color 객체, 색상 요소 또는 CSS 색상"],
      "returns": "알파값"
    },
    "blue": {
      "description": "색상 또는 픽셀 배열로부터 파랑색값 추출합니다.",
      "params": ["p5.Color 객체, 색상 요소, CSS 색상"],
      "returns": "파랑색값"
    },
    "brightness": {
      "description": "색상 또는 픽셀 배열로부터 HSB 밝기값 추출합니다.",
      "params": ["p5.Color 객체, 색상 요소, CSS 색상"],
      "returns": "밝기값"
    },
    "color": {
      "description": "색상 함수를 이용해 색상 데이터의 매개변수를 저장해보세요. 이 때, 매개변수는 colorMode()의 설정에 따라 RGB 또는 HSB 값으로 처리됩니다. 기본 모드인 RGB값은 0부터 255까지이며, 따라서 color(255,204,0)와 같은 함수는 밝은 노랑색을 반환하게 됩니다. <br><br>         만약에 color() 함수에 매개변수가 1개만 적히면, 회색 음영(grayscale)값으로 처리됩니다. 여기에 추가되는 두번째 변수는 투명도를 설정할 수 있는 알파값으로서 처리됩니다. 세번째 변수가 추가되었을 때 비로소 RGB나 HSB값으로 처리되지요. RGB나 HSB값을 정하는 3개의 변수가 존재할 때 추가되는 네번째 변수는 알파값으로 적용됩니다. <br><br> 나아가, p5는 RGB, RGBA, Hex CSS 색상 문자열과 모든 색상명 문자열 역시 지원합니다. 그 경우, 알파값은 괄호 내 2번째 매개변수 추가를 통해서가 아닌, RGBA 형식에 따라 지정될 수 있습니다.",
      "params": ["숫자: 흑과 백 사이의 값 지정",
      "숫자: 현재 색상 범위(기본값: 0-255)에 대한 알파값)",
      "숫자: 현재 색상 범위 내 빨강색(R) 또는 색조값 지정",
      "숫자: 현재 색상 범위 내 파랑색(B) 또는 색조값 지정",
      "문자열: 색상 문자열",
      "숫자[]: RGB 및 알파값을 포함한 숫자열"],
      "returns": "색상 결과"
    },

    "green": {
      "description": "색상 또는 픽셀 배열로부터 초록색값 추출합니다.",
      "params": ["p5.Color 객체, 색상 요소, CSS 색상"],
      "returns": "초록색값"
    },
    "hue": {
      "description": "색상 또는 픽셀 배열로부터 색조를 추출합니다. 색조는 HSB와 HSL상 모두 존재합니다. 이 함수는 HSB 색상 객체를 사용할 경우(또는 HSB 색상 모드로 지정된 픽셀 배열을 사용할 경우) HSB로 표준화된 색조 값을 반환합니다. 기본값으로는 HSL로 표준화된 색조를 반환합니다. (단, 최대 색조가 별도로 지정되어있을 경우 다른 값을 반환합니다.)",
      "params": ["p5.COlor 객체, 색상 요소 또는 CSS 색상"],
      "returns": "색조"
    },
    "lerpColor": {
      "description": "두 가지 색상을 혼합하고, 그 사이에 존재하는 제 3의 색상을 찾습니다. amt 매개변수는 선형보간하는 Mezcla dos colores para encontrar un tercer color según la combinación de ambos. El parámetro amt es la cantidad a interpolar entre los dos valores, donde 0.0 es igual al primer color, 0.1 es muy cercano al primer color, 0.5 está a medio camino entre ambos, etc. Un valor menor que 0 será tratado como 0. Del mismo modo, valores sobre 1 serán tratados como 1. Esto es distinto al comportamiento de lerp(), pero necesario porque de otra manera los números fuera de rango producirían colores no esperados y extraños. La manera en que los colores son interpolados depende del modo de color actual.",
      "params": ["Arreglo/Número: interpola desde este color",
      "Arreglo/Número: interpola hacia este color",
      "Número: número entre 0 y 1"],
      "returns": "Arreglo/Número: color interpolado"
    },
    "lightness": {
      "description": "Extrae el valor de luminosidad HSL de un color o de un arreglo de pixeles.",
      "params": ["Objeto: objeto p5.Color o arreglo de pixeles"],
      "returns": "el objeto p5"
    },
    "red": {
      "description": "Extrae el valor de rojo de un color o de un arreglo de pixeles.",
      "params": ["Objeto: objeto p5.Color o arreglo de pixeles"],
      "returns": "el objeto p5"
    },
    "saturation": {
      "description": "Extrae el valor de saturación de un color o de un arreglo de pixeles. La saturación es escalada en HSB y HSL de forma distinta. Esta función retornará la saturación HSB cuando le sea provisto un objeto de color HSB (o cuando le sea provisto un arreglo de pixeles mientras el modo de color es HSB), pero por defecto retornará saturación HSL.",
      "params": ["Objeto: objeto p5.Color o arreglo de pixeles"],
      "returns": "el objeto p5"
    },
    "background": {
      "description": "background() 함수는 p5.js 캔버스의 배경색을 설정합니다. 배경색의 초기값은 투명입니다. 이 함수는 주로 각 프레임이 시작될 때 화면을 초기화하기 위한 목적으로 draw() 내에서 사용되는데, 배경색을 일회적으로 설정할 경우 setup() 함수 내에서 애니메이션의 첫 프레임의 배경색을 설정하는데 사용되기도 합니다. 색 지정은 RGB, HSB, HSL 세가지 방법으로 할 수 있는데, 모드를 변경하기 위해서는 colorMode() 함수를 이용합니다. 따로 모드 설정을 하지 않는 경우, 색은 RGB로 정의되며 각 숫자의 범위는 0에서 255까지입니다. background()의 괄호 안에 단 한개의 값만 입력하는 것도 가능한데, RGB, RGBA, HEX CSS 모두 사용할 수 있습니다. 단, 투명도를 설정하기 위해서는 반드시 RGBA를 사용해야합니다. 참고로, p5.Color 오브젝트를 통해 배경색을 설정하는 것도 가능합니다. 배경 이미지를 설정하고 싶다면, 레퍼런스의 p5.Image 항목을 참고하세요.",
      "params": ["p5.Color: color() 함수를 통해 만들어진 값",
               "문자열: 색상 문자열, 정수 rgb()나 rgba(), 백분율 rgb()나 rgba(), 3자리 숫자 hex, 6자리 숫자 hex",
               "숫자: 배경색 투명도 (범위 기본값은 0-255이며, 범위는 설정에 따라 다를 수 있음)",
               "숫자: 흑백 채도를 설정함",
               "숫자: 선택한 컬러모드에 따라, red값 혹은 hue값",
               "숫자: 선택한 컬러모드에 따라, green값 혹은 saturation값",
               "숫자: 선택한 컬러모드에 따라, blue값 혹은 brightness값",
               "숫자 배열[]: red, green blud와 투명도를 포함한 배열",
               "p5.Image: loadImage()나 createImage()로 생성된 이미지를 배경 이미지로 설정하는 경우 (스케치 창과 같은 사이즈여야 함)"],
      "returns": "the p5 object"
    },
    "clear": {
      "description": "버퍼 내의 픽셀을 클리어합니다. 본 함수는 createCanvas() 함수로 만들어진 p5.Canvas 오브젝트에만 적용되며, 메인 디스플레이 윈도우에 사용할 수는 없습니다. 메인 그래픽 영역에서와 다르게, createGraphics()를 이용해 생성한 추가 그래픽 영역 내에 있는 픽셀은 완전히 혹은 부분적으로 투명하게 만들 수 있습니다. clear() 함수는 모든 픽셀을 100% 투명하게 만듭니다.",
      "returns": "the p5 object"
    },
    "colorMode": {
      "description": "colorMode()는 p5.js가 색 데이터를 해석하는 방식을 결정합니다. fill(), stroke(), background(), color()의 매개변수의 초기값은 RGB 컬러모드이며, 범위는 0에서 255까지, 즉 colorMode(RGB, 255) 입니다. colorMode(HSB)로 설정하는 경우 HSB 컬러 시스템을 사용할 수 있는데, 초기값은 colorMode(HSB, 360, 100, 100, 1)와 같이 설정됩니다. 컬러모드를 HSL을 설정하는 것도 가능합니다. 참고: 이미 존재하는 컬러 오브젝트들은 자신이 생성되었을 당시의 모드를 기억합니다. 따라서, 이미 존재하는 컬러 오브젝트에 영향을 미치지 않으면서 컬러모드는 바꾸는 것이 가능합니다.",
      "params": ["상수(Constante): RGB (Red/Green/Blue), HSB (Hue/Saturation/Brightness), HSL (Hue/Saturation/Lightness) 중 하나",
      "숫자: 현재 컬러모드에 따라 red 혹은 hue 범위",
      "숫자: 현재 컬러모드에 따라 green 혹은 saturation 범위.",
      "숫자: 현재 컬러모드에 따라 blue 혹은 brightness/lightness 범위.",
      "숫자: 투명도 범위"],
      "returns": "the p5 object"
    },
    "fill": {
      "description": "도형을 칠할 색을 선택합니다. 예를 들어 fill(204, 102, 0)을 실행하면 해당되는 모든 도형들의 색이 주황색으로 바뀝니다. 색 지정은 선택된 colorMode() 값에 따라서 RGB나 HSB로 할 수 있습니다. 초기 컬러모드는 RGB이며 R, G, B 각 값의 범위는 0-255 사이입니다. 투명도 역시 초기값의 범위는 0-255 입니다. RGB, RGBA, Hex CSS 컬러값이나 색 이름과 같이 한개의 문자열을 입력하는 것도 가능합니다. 이러한 경우에는 두번째 변수로 투명도를 입력하는 것이 불가능하므로, RGBA를 사용해야 합니다. 참고로, p5의 Color 오브젝트를 사용해 색을 지정하는 것도 가능합니다.",
      "params": ["숫자: 선택한 컬러모드와 색상값 범위에 따라, red값 혹은 hue값",
      "숫자: 선택한 컬러모드와 색상값 범위에 따라, green값 혹은 saturation값",
      "숫자: 선택한 컬러모드와 색상값 범위에 따라, blue값 혹은 brightness값",
      "숫자: 배경색 투명도 (범위 기본값은 0-255이며, 범위는 설정에 따라 다를 수 있음)",
      "문자열: 문자열로 된 색상값",
      "숫자: 흑백 채도를 설정함",
      "숫자 배열[]: red, green blue와 투명도를 포함한 배열",
      "p5.Color" ],
      "returns": "the p5 object"
    },
    "noFill": {
      "description": "도형에 색을 채우지 않도록 설정합니다. noStroke() 과  noFill()을 동시에 사용하면, 화면에 아무것도 나타나지 않습니다.",
      "returns": "the p5 object"
    },
    "noStroke": {
      "description": "선이나 윤곽선을 그리지 않도록 설정합니다. noStroke() 과  noFill()을 동시에 사용하면, 화면에 아무것도 나타나지 않습니다.",
      "returns": "the p5 object"
    },
    "stroke": {
      "description": "선을 그리거나 도형 윤곽선 색을 설정합니다. 색 지정은 선택된 colorMode() 값에 따라서 RGB나 HSB로 할 수 있습니다. 초기 컬러모드는 RGB이며 R, G, B 각 값의 범위는 0-255 사이입니다. 투명도 역시 초기값의 범위는 0-255 입니다. RGB, RGBA, Hex CSS 컬러값이나 색 이름과 같이 한개의 문자열을 입력하는 것도 가능합니다. 이러한 경우에는 두번째 변수로 투명도를 입력하는 것이 불가능하므로, RGBA를 사용해야 합니다. 참고로, p5의 Color 오브젝트를 사용해 색을 지정하는 것도 가능합니다.",
      "params": ["숫자: 선택한 컬러모드와 색상값 범위에 따라, red값 혹은 hue값",
      "숫자: 선택한 컬러모드와 색상값 범위에 따라, green값 혹은 saturation값",
      "숫자: 선택한 컬러모드와 색상값 범위에 따라, blue값 혹은 brightness값",
      "숫자: 배경색 투명도 (범위 기본값은 0-255이며, 범위는 설정에 따라 다를 수 있음)",
      "문자열: 문자열로 된 색상값",
      "숫자: 흑백 채도를 설정함",
      "숫자 배열[]: red, green blud와 투명도를 포함한 배열",
      "p5.Color"],
      "returns": "the p5 object"
    },
    "arc": {
      "description": "화면에 호를 그립니다. 모드 선택 없이 x, y, w, h, 시작, 끝만을 지정하면 호는 열린 파이조각 형태로 그려집니다. 모드 변수를 설정하기에 따라, 호는 각각 반원(OPEN), 닫혀진 반원(CHORD), 닫혀진 파이조각(PIE) 형태로 그려집니다. ellipseMode() 함수를 이용하면 시작점을 변경할 수 있습니다. 본 함수를 이용해 시작점을 0, 끝점을 TWO_PI로 설정해 원 전체를 그리려 시도하면, 시작점과 끝점이 같기 때문에 아무것도 그려지지 않습니다. 원 전체를 그릴때는 ellipse() 함수를, 원 일부를 그릴 때는 arc() 함수를 이용하세요.",
      "params": ["숫자: 호를 포함하는 원의 x 좌표",
      "숫자: 호를 포함하는 원의 y 좌표",
      "숫자: 호를 포함하는 원의 너비",
      "숫자: 호를 포함하는 원의 높이",
      "숫자: 시작점의 각도로, 호도(radians)로 설정",
      "숫자: 끝점의 각도로, 호도(radians)로 설정",
      "상수: 호를 그리는 방식을 설정함. CHORD, PIEC, OPEN 중 선택. 필수 변수는 아니며 필요한 경우에만 사용하면 됨.",
      "숫자: WEBGL 모드에서만 사용하며, 호의 윤곽선을 구성하는 점(vertices)의 숫자를 지정한다. 필수 변수는 아니며 필요한 경우에만 사용하면 됨. 초기값은 25이다."],
      "returns": "the p5 object"
    },
    "ellipse": {
      "description": "스크린에 타원을 그립니다. 너비와 높이가 같은 경우에는 원이 그려집니다. 첫 두 변수는 위치를, 세번째 네번째 변수는 도형의 너비와 높이를 설정합니다. 높이를 설정하지 않으면 너비 값이 높이로도 사용됩니다. 너비나 높이를 음수로 입력하면, 자동적으로 절대값이 사용됩니다. 원 시작점을 원의 중심으로 둘지의 여부는 ellipseMode() 함수를 이용해 변경할 수 있습니다.",
      "params": ["숫자: 원의 x 좌표",
      "숫자: 원의 y 좌표",
      "숫자: 원의 너비",
      "숫자: 원의 높이",
      "정수: 원을 몇 개의 부분으로 나누어 그릴 것인지 지정 (WEGBL 모드용)"],
      "returns": "the p5 object"
    },

    "line": {
      "description": "화면에 선, 즉 두 점을 연결하는 곧은 선을 그립니다. line() 함수에 4개의 변수를 입력하는 경우 이차원 평면에 선을 그립니다. 선의 색을 지정하려면 stroke() 함수를 이용하세요. 선은 면은 가지고 있지 않기 때문에 면 색을 채우는 fill() 함수는 적용되지 않습니다. 선의 굵기 초기값은 1픽셀이며 이를 변경하기 위해서는 strokeWeight() 함수를 이용합니다.",
      "params": ["숫자: 첫번째 점의 x 좌표",
      "숫자: 첫번째 점의 y 좌표",
      "숫자: 두번째 점의 x 좌표",
      "숫자: 첫번째 점의 y 좌표",
      "숫자: 첫번째 점의 z 좌표",
      "숫자: 두번째 점의 z 좌표"],
      "returns": "the p5 object"
    },
    "point": {
      "description": "Dibuja un punto, una coordenada en el espacio de un pixel de dimensión. El primer parámetro es la coordenada horizontal del punto, el segundo valor es la coordenada vertical del punto. El color del punto es determinado por el trazado actual con la función stroke().",
      "params": ["숫자: x 좌표",
      "숫자: y 좌표",
      "숫자: z 좌표 (WEBGL 모드 사용시)"],
      "returns": "the p5 object"
    },
    "quad": {
      "description": "네모꼴을 그립니다. 네모꼴은 4개의 변을 가진 다각형으로, 직사각형과 유사해 보이지만 직사각형과 다르게 변 사이의 각도가 90도로 고정되어 있지 않습니다. 첫 한 쌍의 변수는 첫 꼭지점을 설정하며 뒤따르는 다른 쌍의 변수들은 시계방향이나 반시계방향으로 차례대로 꼭지점을 설정합니다. z 변수는 WEBGL모드에서 quad() 함수를 사용하는 경우에만 적용됩니다.",
      "params": ["숫자: 첫번째 꼭지점의 x 좌표",
      "숫자: 첫번째 꼭지점의 y 좌표",
      "숫자: 두번째 꼭지점의 x 좌표",
      "숫자: 두번째 꼭지점의 y 좌표",
      "숫자: 세번째 꼭지점의 x 좌표",
      "숫자: 세번째 꼭지점의 y 좌표",
      "숫자: 네번째 꼭지점의 x 좌표",
      "숫자: 네번째 꼭지점의 y 좌표",
      "숫자: 첫번째 꼭지점의 z 좌표",
      "숫자: 두번째 꼭지점의 z 좌표",
      "숫자: 세번째 꼭지점의 z 좌표",
      "숫자: 네번째 꼭지점의 z 좌표"],
      "returns": "the p5 object"
    },
    "rect": {
      "description": "화면에 직사각형을 그립니다. 직사각형은 변이 네개이면서 모든 각도가 90도인 도형입니다. 첫 두 변수는 왼쪽 위 꼭지점의 좌표를, 세번째 변수는 사각형의 너비를, 네번째 변수는 높이를 설정합니다. rectMode() 함수로 사각형 모드를 변경하는 경우 변수 입력값들은 다르게 해석됩니다. 다섯번째, 여섯번째, 일곱번째, 여덟번째 변수를 입력하는 경우 각각의 숫자는 차계로 왼쪽 위, 오른쪽 위, 오른쪽 아래, 왼쪽 아래 모퉁이의 각도를 지정합니다. 각도 변수를 누락하는 경우 앞서 지정한 각도 값이 사용됩니다.",
      "params": ["숫자: 직사각형의 x 좌표값",
      "숫자: 직사각형의 y 좌표값",
      "숫자: 직사각형의 너비",
      "숫자: 직사각형의 높이",
      "숫자: 왼쪽 위 모퉁이 각도 값. 필수 변수가 아니므로 필요한 경우에만 입력.",
      "숫자: 오른쪽 위 모퉁이 각도 값. 필수 변수가 아니므로 필요한 경우에만 입력.",
      "숫자: 오른쪽 아래 모퉁이 각도 값. 필수 변수가 아니므로 필요한 경우에만 입력.",
      "숫자: 왼쪽 아래 모퉁이 각도 값. 필수 변수가 아니므로 필요한 경우에만 입력.",
      "정수: x 방향의 segment 수 (WEBGL 모드에서 사용)",
      "정수: y 방향의 segment 수 (WEBGL 모드에서 사용)"],
      "returns": "the p5 object"
    },
    "triangle": {
      "description": "三角形是个由连接三个点所形成的平面形。前两个参数定义第一个点，中间两个参数定义第二个点而最后两个参数定义第三个点。",
      "params": ["数字：第一个点的 x 坐标",
                 "数字：第一个点的 y 坐标",
                 "数字：第二个点的 x 坐标",
                 "数字：第二个点的 y 坐标",
                 "数字：第三个点的 x 坐标",
                 "数字：第三个点的 y 坐标"],
      "returns": ""
    },
    "ellipseMode": {
      "description": "更改 ellipse() 参数被解读的方式，用以更改椭圆形被画在画布上的位置。<br><br>默认模式为 ellipseMode(CENTER)，ellipse() 前两个参数将被解读成椭圆形的中心点，而第三和第四个参数为宽度和高度。<br><br>ellipseMode(RADIUS) 将 ellipse() 的前两个参数解读成形状的中心点，但是第三和第四个参数被用于定义形状的半径宽度和半径高度<br><br>ellipseMode(CORNER) 将 ellipse() 的前两个参数解读成形状左上角的位置，而第三和第四个参数为宽度和高度<br><br>ellipseMode(CORNERS) 将 ellipse() 的前两个参数解读成形状其中一个角落的位置，而第三和第四个参数则被解读成对面角落的位置。<br><br>参数必须全是大写因为 Javascript 是个区分大小写的编程语言。",
      "params": ["常量：CENTER、RADIUS、CORNER 或 CORNERS"],
      "returns": ""
    },
    "noSmooth": {
      "description": "所有形状的边缘都为锯齿状。注意 smooth() 为默认模式所以您必须调用 noSmooth() 以禁用平滑形状、图像及字体。",
      "returns": ""
    },
    "rectMode": {
      "description": "更改 rect() 参数被解读的方式，用以更改方形被画在画布上的位置。<br><br>默认模式为 rectMode(CORNER), rect() 前两个参数将被解读成形状的左上角的位置，而第三和第四个参数为宽度和高度。<br><br>rectMode(CORNERS) 将 rect() 的前两个参数解读成形状其中一个角落的位置，而第三和第四个参数则被解读成对面角落的位置。<br><br>rectMode(CENTER) 将 rect() 的前两个参数解读成形状的中心点，而第三和第四个参数为宽度和高度。<br><br>rectMode(RADIUS) 也将的前两个参数解读成形状的中心点，但第三和第四个参数被用来定义形状一半的宽度和一半的高度。<br><br>参数必须全是大写因为 Javascript 是个区分大小写的编程语言。",
      "params": ["常量：CORNER、CORNERS、CENTER 或 RADIUS"],
      "returns": ""
    },
    "smooth": {
      "description": "所有形状的边缘都为非锯齿（平滑）状。smooth() 也将提高调整过大小的图像的素质。注意 smooth() 为默认模式；noSmooth() 也能用来禁用平滑形状、图像及字体。",
      "returns": ""
    },
    "strokeCap": {
      "description": "定义线条顶点的风格。顶点风格可以是方形、扩展式或圆形，它们个别参数为：SQUARE、PROJECT 及 ROUND。默认模式为 ROUND。",
      "params": ["常量：SQUARE、PROJECT 或 ROUND"],
      "returns": ""
    },
    "strokeJoin": {
      "description": "定义线条连接的风格。这些链接可以是尖角、斜角或圆角，它们个别参数为：MITER、BEVEL 及 ROUND。默认模式为 MITER。",
      "params": ["常量：MITER、BEVEL 或 ROUND"],
      "returns": ""
    },
    "strokeWeight": {
      "description": "定义线条、点及形状边线的宽度（粗度）。所有宽度单位都是像素。",
      "params": ["数字：线条的粗度（像素单位）"],
      "returns": ""
    },
    "bezier": {
      "description": "在荧幕上画个三次贝塞尔曲线。这些曲线是由一系列锚点和控制点所定义的。前两个参数定义第一个锚点而最后两个参数定义另一个锚点，这也是曲线的第一和最后一个点。中间的参数是用来定义控制点的位置并将决定曲线的形状。一般来说，控制点会将曲线“拉”向它们的方向。",
      "params": ["数字：第一个锚点的 x 坐标",
                 "数字：第一个锚点的 y 坐标",
                 "数字：第一个控制点的 x 坐标",
                 "数字：第一个控制点的 y 坐标",
                 "数字：第二个控制点的 x 坐标",
                 "数字：第二个控制点的 y 坐标",
                 "数字：第二个锚点的 x 坐标",
                 "数字：第二个锚点的 y 坐标",
                 "数字：第一个锚点的 z 坐标",
                 "数字：第一个控制点的 z 坐标",
                 "数字：第二个锚点的 z 坐标",
                 "数字：第二个控制点的 z 坐标"],
      "returns": ""
    },
    "bezierDetail": {
      "description": "定义贝塞尔曲线的解析度<br><br>默认值为 20。<br><br>这函数只有在 WEBGL 模式下有效果因为默认画布渲染模式并不会使用这设定。",
      "params": ["数字：曲线的解析度"],
      "returns": ""
    },
    "bezierPoint": {
      "description": "计算在 a、b、c、d 点定义的贝塞尔曲线上 t 位置的坐标。a 和 d 参数分别为曲线上第一和最后一个点，而 b 和 c 为控制点。最后一个 t 参数可在 0 和 1 的范围内。这函数可以先调用 x 坐标然后在调用 y 坐标已找到曲线上 t 位置的点坐标。",
      "params": ["数字：曲线上第一个点的坐标",
                 "数字：第一个控制点的坐标",
                 "数字：第二个控制点的坐标",
                 "数字：曲线上第二个点的坐标",
                 "数字：介于 0 和 1 之间的值"],
      "returns": "数字：贝塞尔曲线上 t 位置的值"
    },
    "bezierTangent": {
      "description": "计算在 a、b、c、d 点定义的贝塞尔曲线上 t 位置的切线值。a 和 d 参数分别为曲线上第一和最后一个点，而 b 和 c 为控制点。最后一个 t 参数可在 0 和 1 的范围内。",
      "params": ["数字：曲线上第一个点的坐标",
                 "数字：第一个控制点的坐标",
                 "数字：第二个控制点的坐标",
                 "数字：曲线上第二个点的坐标",
                 "数字：介于 0 和 1 之间的值"],
      "returns": "数字：贝塞尔曲线上 t 位置的切线值"
    },
    "curve": {
      "description": "在荧幕上的两点之间画一个曲线，两点由中间四个参数定义。前两个参数为控制点，可以当作曲线是从这个点开始的虽然它并不会被画出来。最后两个参数同样也是用来定义另外一个控制点。<br><br>更长的曲线能使用一系列 curve() 函数创造或使用 curveVertex()。另外一个叫 curveTightness() 的函数提供曲线视觉质量的控制。curve() 函数使用的是 Catmull-Rom 样条函数。",
      "params": ["数字：起点控制点的 x 坐标",
                 "数字：起点控制点的 y 坐标",
                 "数字：第一个点的 x 坐标",
                 "数字：第一个点的 y 坐标",
                 "数字：第二个点的 x 坐标",
                 "数字：第二个点的 y 坐标",
                 "数字：终点控制点的 x 坐标",
                 "数字：终点控制点的 y 坐标",
                 "数字：起点控制点的 z 坐标",
                 "数字：第一个点的 z 坐标",
                 "数字：第二个点的 z 坐标",
                 "数字：终点控制点的 z 坐标"],
      "returns": ""
    },
    "curveDetail": {
      "description": "定义曲线的解析度<br><br>默认值为 20。<br><br>这函数只有在 WEBGL 模式下有效果因为默认画布渲染模式并不会使用这设定。",
      "params": ["数字：曲线的解析度"],
      "returns": ""
    },
    "curveTightness": {
      "description": "更改由 curve() 及 curveVertex() 所创造的曲线的质量。所提供的参数将决定曲线如何切合顶点。0.0 是紧实度的默认值（这值表示曲线为 Catmull-Rom 样条）而 1.0 将使用直线连接所有点。在 -5.0 及 5.0 之间的值会是曲线变形不过他们仍然能被识别而当值越来越大时，曲线也会跟着变形。",
      "params": ["数字：从原顶点的变形量"],
      "returns": ""
    },
    "curvePoint": {
      "description": "计算在 a、b、c、d 点定义的曲线上 t 位置的坐标。a 和 d 参数分别为曲线上第一和最后一个点，而 b 和 c 为控制点。最后一个 t 参数可在 0 和 1 的范围内。这函数可以先调用 x 坐标然后在调用 y 坐标已找到曲线上 t 位置的点坐标。",
      "params": ["数字：曲线上第一个点的坐标",
                 "数字：第一个控制点的坐标",
                 "数字：第二个控制点的坐标",
                 "数字：曲线上第二个点的坐标",
                 "数字：介于 0 和 1 之间的值"],
      "returns": "数字：贝塞尔曲线上 t 位置的值"
    },
    "curveTangent": {
      "description": "计算在 a、b、c、d 点定义的曲线上 t 位置的切线值。a 和 d 参数分别为曲线上第一和最后一个点，而 b 和 c 为控制点。最后一个 t 参数可在 0 和 1 的范围内。",
      "params": ["数字：曲线上第一个点的坐标",
                 "数字：第一个控制点的坐标",
                 "数字：第二个控制点的坐标",
                 "数字：曲线上第二个点的坐标",
                 "数字：介于 0 和 1 之间的值"],
      "returns": "数字：贝塞尔曲线上 t 位置的切线值"
    },
    "beginContour": {
      "description": "使用 beginContour() 及 endContour() 函数以在其他形状内创造剪影形状，比如说 “O” 字母内的空间。beginContour() 将开始记录形状的顶点而 endContour() 则停止记录。定义剪影形状的顶点定义的方向（顺时或逆时针）必须和包含它的形状不同。如果外形的顶点是顺时针方向定义的，那么它里面的形状的顶点需是逆时针方向定义。<br><br>这些函数只能在一对 beginShape()/endShape() 函数之间使用而变形函数如 translate()、rotate() 及 scale() 在一对 beginContour()/endContour() 内并不会有任何效果。其他形状如 ellipse() 或 rect() 也不能在里面使用。",
      "returns": ""
    },
    "beginShape": {
      "description": "使用 beginShape() 及 endShape() 函数可让您创造更复杂的形状。beginShape() 将开始记录形状的顶点而 endShape() 则停止记录。所提供的参数将决定由所提供的顶点该画出怎样的形状。如果模式没有被提供，所定义的形状可以是任何不规则的多边形。<br><br>可提供给 beginShape() 的参数包括 POINTS、LINES、TRIANGLES、TRIANGLE_FAN、TRIANGLE_STRIP、QUADS 及 QUAD_STRIP。在调用 beginShape() 函数之后，一系列 vertex() 函数必须接着调用。调用 endShape() 以停止绘制形状。每个形状都将会有由当时外线色所定义的外线色及当时的填充色。<br><br>变形函数如 translate()、rotate() 及 scale() 在 beginShape() 内不会有任何效果。其他形状如 ellipse() 或 rect() 也不能在beginShape()里面使用。",
      "params": ["常量：POINTS、LINES、TRIANGLES、TRIANGLE_FAN、TRIANGLE_STRIP、QUADS 或 QUAD_STRIP"],
      "returns": ""
    },
    "bezierVertex": {
      "description": "定义贝塞尔曲线的顶点坐标。每次调用 bezierVertex() 将定义贝塞尔曲线的两个控制点和一个锚点，以在线或形状上增加一个新部分。<br><br>在 beginShape() 内第一次调用 bezierVertex() 之前必须先调用一次 vertex() 以定义第一个锚点。这函数只能在 beginShape() 和 endShape() 之间使用并且也只能在 beginShape() 没有任何 MODE（模式）参数的情况下使用。",
      "params": ["数字：第一个控制点的 x 坐标",
                 "数字：第一个控制点的 y 坐标",
                 "数字：第二个控制点的 x 坐标",
                 "数字：第二个控制点的 y 坐标",
                 "数字：第一个锚点的 x 坐标",
                 "数字：第二个锚点的 x 坐标"],
      "returns": ""
    },
    "curveVertex": {
      "description": "定义曲线顶点的坐标。这函数只能在 beginShape() 和 endShape() 之间使用并且也只能在 beginShape() 没有任何 MODE（模式）参数的情况下使用。<br><br>在一系列 curveVertex() 线条中第一个和最后一个点将被用来引导曲线的起点和终点。至少必须提供四个点以画一个介于第二和第三个点的小曲线。增加第五个点将会在第二、第三及第四个点之间画个曲线。curveVertex() 函数使用的是 Catmull-Rom 样条函数。",
      "params": ["数字：顶点的 x 坐标",
                 "数字：顶点的 y 坐标"],
      "returns": ""
    },
    "endContour": {
      "description": "使用 beginContour() 及 endContour() 函数以在其他形状内创造剪影形状，比如说 “O” 字母内的空间。beginContour() 将开始记录形状的顶点而 endContour() 则停止记录。定义剪影形状的顶点定义的方向（顺时或逆时针）必须和包含它的形状不同。如果外形的顶点是顺时针方向定义的，那么它里面的形状的顶点需是逆时针方向定义。<br><br>这些函数只能在一对 beginShape()/endShape() 函数之间使用而变形函数如 translate()、rotate() 及 scale() 在一对 beginContour()/endContour() 内并不会有任何效果。其他形状如 ellipse() 或 rect() 也不能在里面使用。",
      "returns": ""
    },
    "endShape": {
      "description": "endShape() 函数和 beginShape() 是一对的而且它只能在 beginShape() 后使用。当 endshape() 被调用时，自上一次 beginShape() 调用后的所有被定义的图像资料将被写进图像缓冲区。定义常量 CLOSE 给 MODE 参数将会关闭该形状（连接起点和终点）。",
      "params": ["常量：使用 CLOSE 以关闭形状"],
      "returns": ""
    },
    "quadraticVertex": {
      "description": "定义二次贝塞尔曲线顶点的坐标。每次调用 quadraticVertex() 将定义贝塞尔曲线的一个控制点和一个锚点，以在线或形状上增加一个新部分。在 beginShape() 内第一次调用 quadraticVertex() 之前必须先调用一次 vertex() 以定义第一个锚点。这函数只能在 beginShape() 和 endShape() 之间使用并且也只能在 beginShape() 没有任何 MODE（模式）参数的情况下使用。",
      "params": ["数字：控制点的 x 坐标",
                 "数字：控制点的 y 坐标",
                 "数字：锚点的 x 坐标",
                 "数字：锚点的 y 坐标"],
      "returns": ""
    },
    "vertex": {
      "description": "所有形状都是由连接一系列顶点形成的。vertex() 可用于定义点、线、三角形、四角形及多边形的顶点坐标。它只能在 beginShape() 和 endShape() 函数之间使用。",
      "params": ["数字：顶点的 x 坐标",
                 "数字：顶点的 y 坐标",
                 "数字：顶点的 z 坐标",
                 "数字：顶点的纹理 u 坐标",
                 "数字：顶点的纹理 v 坐标"],
      "returns": ""
    },
    "loadModel": {
      "description": "从一个 OBJ 档案加载一个三维模型。<br><br>OBJ 格式的其中一个限制是它没有内建的大小值。这表示不同程式输出的模型可能有非常不同的大小。如果您的模型没被展示的话，请试着调用 loadModel() 并给予 normalized 参数“真”（true）值。这会将模型缩放成适合 p5 的大小。您也可以使用 scale() 函数对您的模型最后大小做与更多的调整。",
      "params": ["字符串：要加载的模型的路径",
                 "布尔值：如果为真，在加载时将模型缩放成标准大小。",
                 "函数(p5.Geometry)：此函数将在模型完成加载后被调用，将被给予该三维模型为参数。",
                 "函数(Event)：如果模型加载失败，此函数将被调用并给予错误事件（event）为参数。"],
      "returns": "p5.Geometry：p5.Geometry 物件"
    },
    "model": {
      "description": "将一个三维模型渲染在荧幕上。",
      "params": ["p5.Geometry：要渲染的已加载的模型"],
      "returns": ""
    },
    "plane": {
      "description": "用给予的宽度和高度画一个平面。",
      "params": ["数字：平面的宽度",
                 "数字：平面的高度",
                 "整数：（可选）在 x 轴的三角形细分数",
                 "整数：（可选）在 y 轴的三角形细分数"],
      "returns": ""
    },
    "box": {
      "description": "用给予的宽度、高度及深度画一个立方体。",
      "params": ["数字：立方体的宽度",
                 "数字：立方体的高度",
                 "数字：立方体的深度",
                 "整数：（可选）在 x 轴的三角形细分数",
                 "整数：（可选）在 y 轴的三角形细分数"],
      "returns": ""
    },
    "sphere": {
      "description": "用给予的半径画一个球形。",
      "params": ["数字：球形的半径",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 24",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 16"],
      "returns": ""
    },
    "cylinder": {
      "description": "用给予的半径和高度画一个圆筒形。",
      "params": ["数字：表面的半径",
                 "数字：圆筒形的高度",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 24",
                 "整数：y 轴分割的数量，越多分割几何形越平滑，默认值为 1",
                 "布尔值：是否该画圆筒形的底部",
                 "布尔值：是否该画圆筒形的顶部"],
      "returns": ""
    },
    "cone": {
      "description": "用给予的半径和高度画一个锥体形。",
      "params": ["数字：底部表面的半径",
                 "数字：锥体形的高度",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 24",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 1",
                 "布尔值：是否该画锥体形的底部"],
      "returns": ""
    },
    "ellipsoid": {
      "description": "用给予的半径画一个椭球形。",
      "params": ["数字：椭球形 x 轴的半径",
                 "数字：椭球形 y 轴的半径",
                 "数字：椭球形 z 轴的半径",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 24。避免多于 150 的细节数量，因为它可能是浏览器停止运作。",
                 "整数：分割的数量，越多分割几何形越平滑，默认值为 16。避免多于 150 的细节数量，因为它可能是浏览器停止运作。"],
      "returns": ""
    },
    "torus": {
      "description": "用给予的半径和管半径画一个圆环形。",
      "params": ["数字：整个圆环形的半径",
                 "数字：圆管的半径",
                 "整数：x 轴分割的数量，越多分割几何形越平滑，默认值为 24。",
                 "整数：y 轴分割的数量，越多分割几何形越平滑，默认值为 16。"],
      "returns": ""
    },
    "HALF_PI": {
      "description": "HALF_PI 是个值为 1.57079632679489661923 的数学常量。它是圆形周长与直径的比例的一半。它能有效的与三角函数如 sin() 及 cos() 一起使用。",
      "returns": ""
    },
    "PI": {
      "description": "PI 是个值为 3.14159265358979323846 的数学常量。它是圆形周长与直径的比例。它能有效的与三角函数如 sin() 及 cos() 一起使用。",
      "returns": ""
    },
    "QUARTER_PI": {
      "description": "QUARTER_PI 是个值为 0.7853982 的数学常量。它是圆形周长与直径的比例的四分之一。它能有效的与三角函数如 sin() 及 cos() 一起使用。",
      "returns": ""
    },
    "TAU": {
      "description": "TAU 是 TWO_PI 的别名，是个值为 6.28318530717958647693 的数学常量。它是圆形周长与直径的比例的两倍。它能有效的与三角函数如 sin() 及 cos() 一起使用。",
      "returns": ""
    },
    "TWO_PI": {
      "description": "TWO_PI 是个值为 6.28318530717958647693 的数学常量。它是圆形周长与直径的比例的两倍。它能有效的与三角函数如 sin() 及 cos() 一起使用。",
      "returns": ""
    },
    "DEGREES": {
      "description": "与 angleMode() 函数一起使用的常量，用于设定 p5.js 如何解读及计算角度（可以是 DEGREES 或 RADIANS）。",
      "returns": ""
    },
    "RADIANS": {
      "description": "与 angleMode() 函数一起使用的常量，用于设定 p5.js 如何解读及计算角度（可以是 DEGREES 或 RADIANS）。",
      "returns": ""
    },
    "preload": {
      "description": "在 setup() 之前被调用，preload() 函数可用来以阻断的方式处理异步加载外来文件。如果 preload 函数有被定义，setup() 将等到其中的加载工作都完成后才开始执行。preload 函数只能含有加载函数（如 loadImage、loadJSON、loadFont、loadStrings 等）。如果您想使用异步加载，加载函数可在 setup() 内或任何其他地方调用，您只需使用其回调函数参数。<br><br>在默认情况下 “loading...” 字眼将会被显示。如果您想只做您自己的加载页面，只需在您也页面上加个 id 为 “p5_loading” 的 HTML 元素。更多详情请查看<a href='http://bit.ly/2kQ6Nio'>这里</a>。",
      "returns": ""
    },
    "setup": {
      "description": "setup() 函数将在程式开始时被调用一次。它可在程序开始时被用来定义初始的环境属性如荧幕大小、背景颜色及媒体加载如图像及字体。每个程序只能有一个 setup() 函数并且他不能在一开始执行后再次被调用。<br><br>请注意：在 setup() 内定义的变量并不能在其他函数内使用，这包括 draw() 。",
      "returns": ""
    },
    "draw": {
      "description": "在 setup() 之后被调用，draw() 函数将持续地重复执行其中的代码直到该程式终止或当 noLoop() 被调用。注意如果 noLoop() 在 setup() 内被调用，draw() 仍然会被执行一个然后才停止。draw() 将会自动被调用并不应该被直接调用。<br><br>您应该使用 noLoop()、redraw() 及 loop() 来控制它。当 noLoop() 停止执行 draw() 内的代码，redraw() 会使 draw() 内的代码执行一次，而 loop() 将会使 draw() 内的代码继续重复执行。<br><br>每一秒 draw() 执行的次数可使用 frameRate() 函数来控制。<br><br>每个绘图只能有一个 draw() 函数，而如果您想持续重复执行代码或处理事件如 mousePressed()，draw() 必须存在。有时候您的程式可能会有空白的 draw() 函数，如以上的范例所示。<br><br>请特别注意绘图坐标系统将在每次 draw() 在开始被调用时重置。任何在 draw() 内执行的变形指令（如 scale、rotate、translate）将会在下一个 draw() 开始时复原，所以变形指令并不会随着时间积累。另一方面，样式（如 fill、stroke等）将会持续同样的效果。",
      "returns": ""
    },
    "remove": {
      "description": "移除整个 p5 绘图。这函数将移除画布及任何由 p5.js 创造的元素。它也会终止绘图循环及解除任何被绑定在窗口对象的属性或函数。它会留下一个 p5 变量以防您还想创造一个新的 p5 绘图。您也可以舍去 p5 = null 以完全删除它。虽然所有由 p5 程式库所创造的函数、变量和物件将会被移除，任何其他由您的代码所定义的公共变量将会被保留。",
      "returns": ""
    },
    "noLoop": {
      "description": "停止 p5.js 持续重复执行 draw() 内的代码。如果 loop() 被调用，draw() 内的代码将开始继续重复执行。如果 noLoop() 在 setup() 被调用，它应该是代码块的最后一行代码。<br><br>在使用 noLoop() 时，您并不能在事件处理函数如 mousePressed() 或 keyPressed() 内操纵或存取荧幕。不过您可以使用哪些函数调用 redraw() 或 loop()，从而执行 draw()，以正确的更新荧幕。这表示当 noLoop() 被调用后，您不能绘制任何东西，同时某些函数如 saveFrame() 或 loadPixels() 也不能使用。<br><br>注意如果绘图的大小改变，redraw() 将会被调用以更新绘图，即使 noLoop() 已经被调用，不然绘图将会处于一个奇怪的状态直到 loop() 再次被调用。",
      "returns": ""
    },
    "loop": {
      "description": "在默认下，p5.js 将会循环执行 draw() 内的代码。不过 draw() 循环能使用 noLoop() 停止。在这情况下 draw() 循环可使用 loop() 函数恢复执行。",
      "returns": ""
    },
    "push": {
      "description": "push() 函数将储存当时的绘画样式设置及变形，而 pop() 将恢复这些设置。注意这两个函数需要一起使用。它们让您改变样式及变形设置然后再回到您之前的设置。当使用 push() 开始一个新的状态时，它将继续建立在当时的样式和变形上。push() 和 pop() 函数可被重复嵌入以提供更复杂的控制。（请参考第二个范例）<br><br>push() 将现有的变形及样式设置资料储存上来，这包括以下的函数：fill()、stroke()、tint()、strokeWeight()、strokeCap()、strokeJoin()、imageMode()、rectMode()、ellipseMode()、colorMode()、textAlign()、textFont()、textMode()、textSize()、textLeading()。",
      "returns": ""
    },
    "pop": {
      "description": "push() 函数将储存当时的绘画样式设置及变形，而 pop() 将恢复这些设置。注意这两个函数需要一起使用。它们让您改变样式及变形设置然后再回到您之前的设置。当使用 push() 开始一个新的状态时，它将继续建立在当时的样式和变形上。push() 和 pop() 函数可被重复嵌入以提供更复杂的控制。（请参考第二个范例）<br><br>push() 将现有的变形及样式设置资料储存上来，这包括以下的函数：fill()、stroke()、tint()、strokeWeight()、strokeCap()、strokeJoin()、imageMode()、rectMode()、ellipseMode()、colorMode()、textAlign()、textFont()、textMode()、textSize()、textLeading()。"
    },
    "redraw": {
      "description": "执行在 draw() 内的代码一次。这函数让该程序只在需要的时候更新显示窗口，比如说当 mousePressed() 或 keyPressed()事件被触发时。<br><br>再构造程式时，只有在如 mousePressed() 之类的时间内调用 redraw() 才有意义，因为 redraw() 并不会直接调用 draw() （它只会表示绘图有需要更新）。<br><br>redraw() 函数并不会在 draw() 内正常运作。以启用/禁用动画，请使用 loop() 及 noLoop()。<br><br>此外您也能定义每次调用 redraw() 将使 draw() 被调用几次。您这需给予一个整数参数已表示执行的次数。",
      "params": ["整数：重绘 n 次。默认值为 1"],
      "returns": ""
    },
    "print": {
      "description": "print() 函数将写入浏览器的控制台区。这函数适用于查看程式生成的资料。这函数每一次被调用将创造新的一行字串。个别元素可使用引号（\"\"）分隔并使用加号（+）连接在一起。",
      "params": ["任何：任何要写进控制台的数字、字符串、物件、布尔值或数组的组合"],
      "returns": ""
    },
    "frameCount": {
      "description": "系统变量 frameCount 存着自程序开始已被展示的影格数量。在 setup() 这值为 0，在第一次执行 draw() 后为 1 等等。",
      "returns": ""
    },
    "focused": {
      "description": "确定 p5.js 程式正在运行的窗口是否获得“焦点”，这表示绘图可接受滑鼠或键盘输入。如果窗口获得焦点，次变量为 “true” 否则为 “false”。",
      "returns": ""
    },
    "cursor": {
      "description" : "设置鼠标成预定的符号或一个图像，或者如果鼠标被隐藏显示鼠标。如果你想要设置一个图像为鼠标，建议的图像大小为 16x16 或 32x32 像素。 It is not possible to load an image as the cursor if you are exporting your program for the Web, and not all MODES work with all browsers. 参数 x 及 y 必须低于图像的大小。",
      "params": ["字符串|常量：ARROW、CROSS、HAND、MOVE、TEXT 或图像的路径",
                 "数字：鼠标的横向活跃点",
                 "数字：鼠标的直向活跃点"],
      "returns": ""
    },
    "frameRate": {
      "description": "定义每一秒应该显示的影格数。比如说，调用 frameRate(30) 将使绘图每秒刷新 30 次。如果处理器没法跟上所定义的速率，该帧率将不会被达到。建议在 setup() 内设置帧率。默认的帧率值为每秒 60 影格。这和调用 setFrameRate(val) 的效果一样。<br><br>调用 frameRate() 但不给予任何参数将会返回当时的帧率。draw() 函数必须至少执行一次它才会返回帧率。这和调用 getFrameRate() 的效果一样。<br><br>调用 frameRate() 并给予任何不是数字或正数的参数也将会返回当时的帧率。",
      "params": ["数字：每一秒该显示的影格数"],
      "returns": ""
    },
    "noCursor": {
      "description": "隐藏鼠标。",
      "returns": ""
    },

    "displayWidth": {
      "description": "储存整个荧幕宽度的系统变量。这可用来在任何大小的荧幕制作任何大小的全屏程序。",
      "returns": ""
    },
    "displayHeight": {
      "description": "储存整个荧幕高度的系统变量。这可用来在任何大小的荧幕制作任何大小的全屏程序。",
      "returns": ""
    },
    "windowWidth": {
      "description": "储存窗口内部宽度的系统变量， 此函数映射 window.innerWidth。",
      "returns": ""
    },
    "windowHeight": {
      "description": "储存窗口内部高度的系统变量， 此函数映射 window.innerHeight。",
      "returns": ""
    },
    "windowResized": {
      "description": "windowResized() 函数将在每次浏览器窗口缩放时被调用。这是个适合缩放画布及或任何其他调整以符合新的窗口大小的地方。",
      "returns": ""
    },
    "width": {
      "description": "储存画布宽度的系统变量。这值是由 createCanvas() 函数的第一个参数所定义。比如说，调用函数 createCanvas(320, 240) 将定义此宽度变量为 320。如果一个程式没有使用 createCanvas() 宽度值将默认为 100。",
      "returns": ""
    },
    "height": {
      "description": "储存画布高度的系统变量。这值是由 createCanvas() 函数的第二个参数所定义。比如说，调用函数 createCanvas(320, 240) 将定义此高度变量为 240。如果一个程式没有使用 createCanvas() 高度值将默认为 100。",
      "returns": ""
    },
    "fullscreen": {
      "description": "如果提供一个参数，依该参数而定该绘图是否是全屏。如果没有给予任何参数，将返回当时的全屏状态。注意因为浏览器限制，此函数只能在使用者输入时调用，比如说在滑鼠点击时如以上范例。",
      "params": ["布尔值：该绘图是否应该是全屏"],
      "returns": "布尔值：当时的全屏状态"
    },
    "pixelDensity": {
      "description": "定义像素缩放值，用于高像素密度显示器。默认像素密度为显示器的像素密度，可调用 pixelDensity(1) 以关闭此功能。调用 pixelDensity() 并不给予任何参数将返回该绘图的像素密度。",
      "params": ["数字：绘图是否应该缩放及缩放多少"],
      "returns": "数字：该绘图的像素密度"
    },
    "displayDensity": {
      "description": "返回正在运行该绘图的显示器的像素密度。",
      "returns": "数字：该显示器的像素密度"
    },
    "getURL": {
      "description": "返回当下的网址。",
      "returns": "字符串：网址"
    },
    "getURLPath": {
      "description": "返回当下的网址的路径数组",
      "returns": "字符串[]：路径组"
    },
    "getURLParams": {
      "description": "返回当下网址的参数物件",
      "returns": "物件：网址参数"
    },

    "createCanvas": {
      "description": "캔버스를 생성하고 픽셀 단위로 크기를 설정합니다. createCanvas()는 setup() 시작시에 한번만 실행되어야 합니다. createCanvas()를 1번 이상 호출하면 스케치가 예기치 못한 반응을 보일 수 있습니다. 2개 이상의 캔버스가 필요하다면 createGraphics()를 이용하세요. 설정한 캔버스 사이즈는 시스템 변수인 width와 height에 각각 저장됩니다. createCanvas() 자체를 생략하면 스케치는 디폴트 사이즈인 100x100픽셀이 됩니다. 캔버스의 위치를 정하는 다른 방식들을 알고싶다면, 위키 페이지의 'positioning the canvas'를  참고하세요.",
      "params": ["숫자: 캔버스의 너비",
      "숫자: 캔버스의 높이",
      "상수: P2D 또는 WEBGL"]
    },
      
    "resizeCanvas": {
      "description": "缩放画布至给予的宽度和高度。该画布将会马上被清空及调用 draw()，使得画布能在缩放后重新渲染。",
      "params": ["数字：画布的宽度",
                 "数字：画布的高度",
                 "布尔值：不要马上更新画布"],
      "returns": ""
    },
    "noCanvas": {
      "description": "如果该 p5 绘图不需要画布，此函数将移除默认画布。",
      "returns": ""
    },
    "createGraphics": {
      "description": "创造及返回一个新的 p5.Renderer 物件。如果您需要在一个画面外的图形缓冲区作画，您可以使用这个函数。前两个参数将定义宽度和高度像素。",
      "params": ["数字：画面外图形缓冲区的宽度",
                 "数字：画面外图形缓冲区的高度",
                 "常量：P2D 或 WEBGL，默认为 P2D"],
      "returns": "buffer gráfico fuera de pantalla"
    },
    "blendMode": {
      "description": "根据所设定的模式在显示窗口内混合像素。以下模式选择可用来混合源像素（A）与已经在显示窗口的像素（B）：<ul><li><code>BLEND</code> - 颜色线性插值：C = A*系数 + B。这是默认混合模式。</li><li><code>ADD</code> - A 与 B 的总和</li><li><code>DARKEST</code> - 将显示当中最深的颜色：C = min(A*系数, B)。</li><li><code>LIGHTEST </code> - 将显示当中最浅的颜色：C = max(A*系数, B)。</li><li><code>DIFFERENCE</code> - 从底下的图像中减去颜色。</li><li><code>EXCLUSION</code> - 与 DIFFERENCE 相似但不那么强烈。</li><li><code>MULTIPLY</code> - 将颜色相乘，效果一定会更暗。</li><li><code>SCREEN</code> - 与 MULTIPLY 相反，使用颜色的反值。</li><li><code>REPLACE</code> - 像素将完全盖过其他像素并将不会使用透明度值。</li><li><code>OVERLAY</code> - MULTIPLY 及 SCREEN 和混合。暗值将相乘，亮值将相乘反值。</li><li><code>HARD_LIGHT</code> - 当高于 50% 灰时 SCREEN，低于时 MULTIPLY。</li><li><code>SOFT_LIGHT</code> - DARKEST 及 LIGHTEST 的混合。与 OVERLAY 的效果相似，但不那么强烈。</li><li><code>DODGE</code> - 使浅色更浅及增加对比度，忽略暗色。</li><li><code>BURN</code> - 是深色更深及增加对比度，忽略浅色。</li></ul>",
      "params": ["常量：画布的混合模式。BLEND、DARKEST、LIGHTEST、DIFFERENCE、MULTIPLY、EXCLUSION、SCREEN、REPLACE、OVERLAY、HARD_LIGHT、SOFT_LIGHT、DODGE、BURN、ADD 或 NORMAL"],
      "returns": ""
    },
    "setAttributes": {
      "description": "设置 WebGL 绘图环境的属性。这是调整 WebGL 渲染器的一个方法，可用于微调显示及性能。这函数应该在 setup() 内使用。可使用的属性为：<br>alpha - 表示画布是否有透明度缓冲，默认为 true<br><br>depth - 表示绘图缓冲是否有至少 16 bits 的深度缓冲 - 默认为 true<br><br>stencil - 表示绘图缓冲是否有至少 8 bits 的模版缓冲<br><br>antialias - 表示是否应该执行抗锯齿，默认为 false<br><br>premultipliedAlpha - 表示页面合成器将假设绘图缓冲存在着预乘透明值的颜色，默认为 false<br><br>preserveDrawingBuffer - 如果为真缓冲区将不会被清空并将会保留现有的值直到它们被清空或被作者覆盖（注意 p5 在绘图循环将自动清空），默认为 true<br><br>perPixelLighting - 如果为真，照明着色器将使用个别像素照明。默认为 false",
      "params": ["字符串：属性名",
                 "布尔值：属性的新值",
                 "物件：有键值对的物件"]
    },
    "applyMatrix": {
      "description": "将现有的矩阵乘于由参数所定义的矩阵。这是个强大的功能并能够同时执行平移、缩放、切变及旋转。您能在<a href='https://zh.wikipedia.org/wiki/%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5'>维基百科</a>了解更多关于变形矩阵的资讯。<br><br>这里的参数命名跟着 <a href='https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-transform'>WHATWG 规范</a>（英文页面）的命名方式并代表着一个如下的变形矩阵：<blockquote><p><img style='max-width: 150px' src='assets/transformation-matrix.png' alt='当 applyMatrix 被调用时所使用的变形矩阵'></p></blockquote>",
      "params": ["数字：定义该乘于的 2x3 矩阵",
                 "数字：定义该乘于的 2x3 矩阵",
                 "数字：定义该乘于的 2x3 矩阵",
                 "数字：定义该乘于的 2x3 矩阵",
                 "数字：定义该乘于的 2x3 矩阵",
                 "数字：定义该乘于的 2x3 矩阵"],
      "returns": ""
    },
    "resetMatrix": {
      "description": "将现有的矩阵替换成单位矩阵。",
      "returns": ""
    },
    "rotate": {
      "description": "将一个形状根据参数所定义的角度旋转。这函数将考虑角度模式，所以角度可以是弧度或角度定义。<br><br>所有物件都会绕着原点旋转而正数将使物件在顺时针方向旋转。此变形将影响接下来所有的绘图并且接下来此函数调用效果将累积。比如说，调用 rotate(HALF_PI) 然后 rotate(HALF_PI) 效果会与 rotate(PI) 相同。所有变形将会在 draw() 重新开始时恢复。",
      "params": ["数字：旋转的角度，根据当时的角度模式，以弧度或角度定义",
                 "p5.Vector|数字[]：（3D 模式下）旋转轴"],
      "returns": ""
    },
    "rotateX": {
      "description": "绕着 x 轴旋转。",
      "params": ["数字：旋转角度，根据当时的角度模式，以弧度或角度定义"],
      "returns": ""
    },
    "rotateY": {
      "description": "绕着 y 轴旋转。",
      "params": ["数字：旋转角度，根据当时的角度模式，以弧度或角度定义"],
      "returns": ""
    },
    "rotateZ": {
      "description": "绕着 x 轴旋转。只适用于 WEBGL 模式。",
      "params": ["数字：旋转角度，根据当时的角度模式，以弧度或角度定义"],
      "returns": ""
    },
    "scale": {
      "description": "通过扩大和收缩顶点，放大或缩小形状。形状物件将会从坐标系统的原点开始缩放。缩放值为十进制百分比。比如说，调用函数 scale(2.0) 将使该形状放大 200%。<br><br>此变形将影响接下来所有的绘图并且接下来此函数调用效果将累积相乘。比如说，调用 scale(2.0) 然后 scale(1.5) 效果会与 scale(3.0) 相同。如果 scale() 在 draw() 内被调用，变形将会在下一次循环开始时恢复。<br><br>给予此函数一个 z 参数只在 WEBGL 模式下受支持。这函数能使用 push() 及 pop() 控制。",
      "params": ["数字|p5.Vector|数字[]：缩放物件的百分比，或如果给予多个参数 x 轴的缩放百分比",
                 "数字：y 轴的缩放百分比",
                 "数字：z 轴的缩放百分比（只适用于 WEBGL 模式）",
                 "p5.Vector|数字[]：各轴缩放百分比"],
      "returns": ""
    },
    "shearX": {
      "description": "有角度参数所定义的形状 x 轴切变量。角度必须符合当时的角度模式。形状物件将会从坐标系统的原点开始切变而正数表示切变方向为顺时针方向。<br><br>此变形将影响接下来所有的绘图并且接下来此函数调用效果将累积。比如说，调用 shearX(PI/2) 然后 shearX(PI/2) 效果会与 shearX(PI) 相同。如果 shearX() 在 draw() 内被调用，变形将会在下一次循环开始时恢复。<br><br>技术上，shearX() 将现有的变形矩阵乘以一个旋转矩阵。这函数能使用 push() 及 pop() 控制。",
      "params": ["数字：根据当时的角度模式，以弧度或角度定义和切变角度"],
      "returns": ""
    },
    "shearY": {
        "description": "有角度参数所定义的形状 y 轴切变量。角度必须符合当时的角度模式。形状物件将会从坐标系统的原点开始切变而正数表示切变方向为顺时针方向。<br><br>此变形将影响接下来所有的绘图并且接下来此函数调用效果将累积。比如说，调用 shearY(PI/2) 然后 shearY(PI/2) 效果会与 shearY(PI) 相同。如果 shearY() 在 draw() 内被调用，变形将会在下一次循环开始时恢复。<br><br>技术上，shearY() 将现有的变形矩阵乘以一个旋转矩阵。这函数能使用 push() 及 pop() 控制。",
        "params": ["数字：根据当时的角度模式，以弧度或角度定义和切变角度"],
        "returns": ""
    },
    "translate": {
      "description": "定义在显示窗口内平移物件的量。x 参数将定义左/右平移，y 参数将定义上/下平移。<br><br>此变形将影响接下来所有的绘图并且接下来此函数调用效果将累积。比如说，调用 translate(50, 0) 然后 translate(20, 0) 效果会与 translate(70, 0) 相同。如果 translate() 在 draw() 内被调用，变形将会在下一次循环开始时恢复。这函数能使用 push() 及 pop() 控制。",
      "params": ["数字：左/右平移",
                 "数字：上/下平移",
                 "数字：前/后平移（只适用于 WEBGL 模式）",
                 "p5.Vector：平移向量"],
      "returns": ""
    },

    "deviceOrientation": {
      "description": "deviceOrientation 系统变量将会储存设备的旋转方向。此变量的值可以是 ‘landscape’ 或 ‘portrait’。如果没有资料可用他会被定义成 ‘undefined’。LANDSCAPE 或 PORTRAIT。",
      "returns": ""
    },
    "accelerationX": {
      "description": "accelerationX 系统变量将会储存设备的 x 轴加速度。值的单位为每平方秒米。",
      "returns": ""
    },
    "accelerationY": {
      "description": "accelerationY 系统变量将会储存设备的 y 轴加速度。值的单位为每平方秒米。",
      "returns": ""
    },
    "accelerationZ": {
      "description": "accelerationZ 系统变量将会储存设备的 z 轴加速度。值的单位为每平方秒米。",
      "returns": ""
    },
    "pAccelerationX": {
      "description": "pAccelerationX 系统变量将会储存上一个影格该设备的 x 轴加速度。值的单位为每平方秒米。",
      "returns": ""
    },
    "pAccelerationY": {
      "description": "pAccelerationY 系统变量将会储存上一个影格该设备的 y 轴加速度。值的单位为每平方秒米。",
      "returns": ""
    },
    "pAccelerationZ": {
      "description": "pAccelerationZ 系统变量将会储存上一个影格该设备的 z 轴加速度。值的单位为每平方秒米。",
      "returns": ""
    },
    "rotationX": {
      "description": "rotationX 系统变量将会储存设备在 x 轴的旋转角度。值介于 0 与 +/-180 度之间。<br><br>注意：旋转的顺序很重要，比如说，如果同时使用它们必须依 Z-X-Y 的顺序调用或可能会有难以预料的行为。",
      "returns": ""
    },
    "rotationY": {
      "description": "rotationY 系统变量将会储存设备在 y 轴的旋转角度。值介于 0 与 +/-90 度之间。<br><br>注意：旋转的顺序很重要，比如说，如果同时使用它们必须依 Z-X-Y 的顺序调用或可能会有难以预料的行为。",
      "returns": ""
    },
    "rotationZ": {
      "description": "rotationZ 系统变量将会储存设备在 z 轴的旋转角度。值介于 0 与 359 度之间。<br><br>与 rotationX 及 rotationY 不同的是，这变量只能在有内建指南针的设备使用。<br><br>注意：旋转的顺序很重要，比如说，如果同时使用它们必须依 Z-X-Y 的顺序调用或可能会有难以预料的行为。",
      "returns": ""
    },
    "pRotationX": {
      "description": "pRotationX 系统变量将会储存上一个影格该设备在 x 轴的旋转角度。值介于 0 与 +/-180 度之间。<br><br>pRotationX 可以和 rotationX 一起使用以找出设备 x 轴的旋转方向。",
      "returns": ""
    },
    "pRotationY": {
      "description": "pRotationY 系统变量将会储存上一个影格该设备在 y 轴的旋转角度。值介于 0 与 +/-90 度之间。<br><br>pRotationY 可以和 rotationY 一起使用以找出设备 y 轴的旋转方向。",
      "returns": ""
    },
    "pRotationZ": {
      "description": "pRotationZ 系统变量将会储存上一个影格该设备在 z 轴的旋转角度。值介于 0 与 359 度之间。<br><br>pRotationZ 可以和 rotationZ 一起使用以找出设备 z 轴的旋转方向。",
      "returns": ""
    },
    "setMoveThreshold": {
      "description": "setMoveThreshold() 函数可用来设置 deviceMoved() 函数的移动阈值。默认阈值为 0.5。",
      "params": ["数字：阈值"],
      "returns": ""
    },
    "setShakeThreshold": {
      "description": "setShakeThreshold() 函数可用来设置 deviceShaken() 函数的摇动阈值。默认阈值为 30。",
      "params": ["数字：阈值"],
      "returns": ""
    },
    "deviceMoved": {
      "description": "deviceMoved() 函数将在设备在 X、Y 或 Z 轴被移动多过阈值时被调用。默认阈值为 0.5。",
      "returns": ""
    },
    "deviceTurned": {
      "description": "deviceTurned() 函数将在设备被连续旋转多过 90 度时被调用。<br><br>触发 deviceTurned() 的旋转轴将被储存在 turnAxis 变量中。deviceTurned() 函数能被锁定在 X、Y 或 Z 以确保只有所定义的轴会导致函数被调用，您只需比较 turnAxis 变量和 'X'、'Y' 或 'Z' 字符串。",
      "returns": ""
    },
    "deviceShaken": {
      "description": "deviceShaken() 函数将在设备的 accelerationX 及 accelerationY 加速度值改变超过阈值。默认阈值为 30。",
      "returns": ""
    },
    "keyIsPressed": {
      "description": "keyIsPressed 布尔系统变量将会在任何键被按下时为真（true）而没键被按下时为假（false）。",
      "returns": ""
    },
    "key": {
      "description": "key 系统变量将会储存上一个被键入的键盘键值。以获得正确的大小写，最好在 keyTyped() 内使用。至于非 ASCII 值的键，请使用 keyCode 变量。",
      "returns": ""
    },
    "keyCode": {
      "description": "keyCode 变量可用来探测特别键如 BACKSPACE、DELETE、ENTER、RETURN、TAB、ESCAPE、SHIFT、CONTROL、OPTION、ALT、UP_ARROW、DOWN_ARROW、LEFT_ARROW、RIGHT_ARROW 是否被按下。您也可以使用特别网站如 <a href='http://keycode.info/'>keycode.info</a> 以找出自定义键的 keyCode。",
      "returns": ""
    },
    "keyPressed": {
      "description": "keyPressed() 函数将会在每一次任何键被按下时被调用。被按下的键的 keyCode 将被储存在 keyCode 变量内。<br><br>对于非 ASCII 值的键，请使用 keyCode 变量。您能查看 keyCode 是否等于 BACKSPACE、DELETE、ENTER、RETURN、TAB、ESCAPE、SHIFT、CONTROL、OPTION、ALT、UP_ARROW、DOWN_ARROW、LEFT_ARROW、RIGHT_ARROW。<br><br>至于 ASCII 键值它们的值会被储存在 key 变量内。不过，它并不会分辨大小写。因此，建议使用 keyTyped() 以读取 key 变量，因为其大小写在这里会被分辨出来。<br><br>取决于操作系统如何处理按键重复，按住一个键可能使 keyTyped() （及 keyReleased()）被调用多过一次。重复的速度应操作系统及该电脑的设置而定。<br><br>不同浏览器可能会有不同附属于个别键盘事件的默认行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "keyReleased": {
      "description": "keyReleased() 函数将会在每一次任何键被释放时被调用。请查看 key 及 keyCode 以知更多详情。<br><br>不同浏览器可能会有不同附属于个别键盘事件的默认行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "keyTyped": {
      "description": "keyTyped() 函数将会在每一次任何键被按下时被调用，可是会忽略操作键如 Ctrl、Shift 及 Alt。被按下的键的 keyCode 将被储存在 keyCode 变量内。<br><br>取决于操作系统如何处理按键重复，按住一个键可能使 keyTyped() （及 keyReleased()）被调用多过一次。重复的速度应操作系统及该电脑的设置而定。<br><br>不同浏览器可能会有不同附属于个别键盘事件的默认行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "keyIsDown": {
      "description": "keyIsDown() 函数将查看被提供的键是否正被按下。它能在当您需要使用多个不同的键同时用来移动一个物件时使用（如将一个图像往斜移动）。您能给予任何代表该键的 keyCode 会任何<a href='http://p5js.org/zh-Hans/reference/#p5/keyCode'>此页</a>的 keyCode 变量名为参数。",
      "params": ["数字：该查看的键"],
      "returns": ""
    },
    "mouseX": {
      "description": "mouseX 系统变量将会储存当时的鼠标相对于画布 (0, 0) 位置的的横向位置。如果使用的是触动而不是滑鼠的话，mouseX 将会储存上一个触动点的 x 值。",
      "returns": ""
    },
    "mouseY": {
      "description": "mouseY 系统变量将会储存当时的鼠标相对于画布 (0, 0) 位置的的直向位置。如果使用的是触动而不是滑鼠的话，mouseY 将会储存上一个触动点的 y 值。",
      "returns": ""
    },
    "pmouseX": {
        "description": "pmouseX 系统变量将会储存上一个影格鼠标或触动点相对于画布 (0, 0) 位置的的横向位置。",
        "returns": ""
    },
    "pmouseY": {
      "description": "pmouseY 系统变量将会储存上一个影格鼠标或触动点相对于画布 (0, 0) 位置的的直向位置。",
      "returns": ""
    },
    "winMouseX": {
      "description": "winMouseX 系统变量将会储存当时鼠标相对于窗口 (0, 0) 位置的横向位置。",
      "returns": ""
    },
    "winMouseY": {
      "description": "winMouseY 系统变量将会储存当时鼠标相对于窗口 (0, 0) 位置的直向位置。",
      "returns": ""
    },
    "pwinMouseX": {
      "description": "pwinMouseX 系统变量将会储存上一个影格鼠标相对于窗口 (0, 0) 位置的横向位置。",
      "returns": ""
    },
    "pwinMouseY": {
      "description": "pwinMouseY 系统变量将会储存上一个影格鼠标相对于窗口 (0, 0) 位置的直向位置。",
      "returns": ""
    },
    "mouseButton": {
      "description": "p5 将自动记录滑鼠键是否被按下及哪个键被按下。mouseButton 系统变量的值可能是 LEFT、RIGHT 或 CENTER，取决于上一个被按下的滑鼠键。请注意：不同的浏览器可能记录不同的 mouseButton 值。",
      "returns": ""
    },
    "mouseIsPressed": {
      "description": "mouseIsPressed 系统变量将会在滑鼠键被按下时为真（true），而没按下时为假（false）。",
      "returns": ""
    },
    "mouseMoved": {
      "description": "mouseMoved() 函数将在每次鼠标移动而滑鼠键没有被按下的时候被调用。<br><br>不同浏览器可能有不同附属于个别滑鼠事件的行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "mouseDragged": {
      "description": "mouseDragged() 函数将在每次鼠标移动及滑鼠键正被按下的时候被调用。如果 mouseDragged() 函数并未有被定义，touchMoved() 函数有被定义的话将会被调用。<br><br>不同浏览器可能有不同附属于个别滑鼠事件的行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "mousePressed": {
      "description": "mousePressed() 函数将在每次滑鼠键被按下时被调用。mouseButton 函数（请参考其文献）可以被用来探测哪一个滑鼠键刚被按下。如果 mousePressed() 函数并未有被定义，touchStarted() 函数有被定义的话将会被调用。<br><br>不同浏览器可能有不同附属于个别滑鼠事件的行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "mouseReleased": {
      "description": "mouseReleased() 函数将在每次滑鼠键被释放时被调用。如果 mouseReleased() 函数并未有被定义，touchEnded() 函数有被定义的话将会被调用。<br><br>不同浏览器可能有不同附属于个别滑鼠事件的行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "mouseClicked": {
      "description": "mouseClicked() 函数将在滑鼠键被按下然后被释放后被调用。<br><br>不同浏览器处理滑鼠点击的方式不大一样，所以这函数只有在滑鼠左键被点击时才保证会被触发。如果想要处理其他滑鼠键的点击或释放事件，请参考 mousePressed() 或 mouseReleased()。<br><br>不同浏览器可能有不同附属于个别滑鼠事件的行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "doubleClicked": {
      "description": "doubleClicked() 函数将在 dblclick 事件被触发式被调用，dblclick 时间是 DOM L3 规范的一部分。doubleClicked 将在滑鼠键（通常为左键）连续两次在同样一个元素上点击时被触发。以知更多详情请参考 Mozilla 的参考文献：<a href='https://developer.mozilla.org/en-US/docs/Web/Events/dblclick'>https://developer.mozilla.org/en-US/docs/Web/Events/dblclick</a>。"
    },
    "mouseWheel": {
      "description": "mouseWheel() 函数将在每次直向滑鼠滚轮事件被触发式被调用，可以由实际的滑鼠滚轮或摸板触发。<br><br>event.delta 属性将返回滑鼠滚轮所滚动的量。这值可以是正数或负数，取决于滚动的方向（在 OS X 如果启用“自然”滚屏方向，正反方向将相反）。",
      "returns": ""
    },
    "touches": {
      "description": "touches[] 系统变量将储存一个含有现在所有触动点相对于画布 (0, 0) 位置的位置数组，及分辨个别触动点移动时的 ID。数组内的每个元素都会有 x、y 及 id 属性。<br><br>touches[] 数组并不受 Safari 及 IE 移动设备（包括手提电脑）所支持。",
      "returns": ""
    },
    "touchStarted": {
      "description": "touchStarted() 函数将在每次触动事件被触发时被调用。如果 touchStarted() 函数并未有被定义，mousePressed() 函数有被定义的话将会被调用。<br><br>不同浏览器可能有不同附属于个别触动事件的行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "touchMoved": {
      "description": "touchMoved() 函数将在每次触点移动事件被触发时被调用。如果 touchMoved() 函数并未有被定义，mouseDragged() 函数有被定义的话将会被调用。<br><br>不同浏览器可能有不同附属于个别触动事件的行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "touchEnded": {
      "description": "touchEnded() 函数将在每次触动结束时被调用。如果 touchEnded() 函数并未有被定义，mouseReleased() 函数有被定义的话将会被调用。<br><br>不同浏览器可能有不同附属于个别触动事件的行为。以防止这些默认行为发生，只需在函数尾端加 “return false”。",
      "returns": ""
    },
    "createImage": {
      "description": "创造一个新的 p5.Image 物件（储存图像的数据类型）。这将提供一个全新的像素缓冲供您使用。缓冲区的大小将由所提供的宽度和高度参数决定。<br><br>.pixels 将提供一个含有所有像素资料的数组。这些值都为数字。这数组的大小为（同时考虑像素密度）显示窗口的大小 x4，分别代表每个像素由左到右，上到下的 R、G、B、A 值。请参考 .pixels 文献。您也能使用更简单的 set() 或 get()。<br><br>在获取一个图像的像素之前，像素资料必须先使用 loadPixels() 函数加载。在数组资料被修改后，updatePixels() 函数必须被调用以更新图像资料。",
      "params": ["整数：像素宽度",
                 "整数：像素宽度"],
      "returns": "p5.Image：p5.Image 物件"
    },
    "saveCanvas": {
      "description": "将现有的画布储存成图像。In Safari, this will open the image in the window and the user must provide their own filename on save-as. Other browsers will either save the file immediately, or prompt the user with a dialogue window.",
      "params": ["p5.Element|HTMLCanvasElement：una variable representando un canvas HTML5 específico (opcional)",
                 "字符串",
                 "字符串：'jpg' 或 'png'"],
      "returns": ""
    },
    "saveFrames": {
      "description": "捕捉一系列可用于制作影响的影格图像。接受回调函数。比如说，您可能想要将影格传送至伺服器以方便储存或转变成影像。如果回调函数没有被提供，浏览器将弹出储存文件对话框以尝试下载所有刚被创造的图像。如果提供回调函数，图像资料默认上并不会被储存而是以物件数组的形式被转送至回调函数做参数，数组大小为储存影格的总数。",
      "params": ["字符串",
                 "字符串：'jpg' 或 'png'",
                 "数字：该捕捉的影格的秒数",
                 "数字：捕捉影格的帧率",
                 "函数(数组)：一个用来处理图像资料的回调函数。此函数将会被给予一个数组为参数。此数组将会储存所定义的捕捉影格物件。每一个物件都会有三个属性：imageData - 为 image/octet-stream 类型、filename 及 extension。"],
      "returns": ""
    },
    "loadImage": {
      "description": "설정한 경로에서 이미지를 불러오고 p5.Image를 생성합니다. 이미지를 불러온 후 바로 렌더링이 가능하지 않은 경우도 있습니다. 이를 피하려면 loadImage()를 preload()에서 호출하거나, 이미지가 준비된 후 다른 명령을 하도록 하는 콜백 함수를 이용하세요. 이미지 경로는 스케치에 링크된 HTML 파일을 기준으로 상대 경로를 사용합니다. URL이나 원격 경로를 이용하면 브라우저의 보안 설정에 따라 이미지를 불러오는데에 문제가 생길 수 있습니다.",
      "params": ["문자열: 불러올 이미지 경로",
      "함수(p5.Image): 이미지를 불러온 후 호출할 함수",
      "함수(Event): 이미지 불러오기를 실패하는 경우에 호출할 함수"]
    },
    "image": {
      "description": "p5.js 캔버스에 이미지를 배치합니다. 본 함수를 사용하는 몇가지 방법을 소개하자면 다음과 같습니다. (1) 가장 간단한 방법은 img, x, y 세 개의 변수를 사용하는 방법입니다. x, y는 이미지의 위치를 지정합니다. (2) 이미지의 크기를 설정하려면 img, x, y와 더불어 이미지의 너비와 높이를 설정하는 두개의 변수를 추가로 사용합니다. (3) 여덟개의 변수를 사용하는 방법입니다. 먼저, 각 변수들을 구별하기 위해 p5.js에서 사용하는 용어를 배워봅시다. 첫번째 용어는 '목적지 사각형(destination rectagle)로, dx, dy 등의 변수가 이에 해당합니다. 두번째 용어는 '원본 이미지(source image)'로, sx, sy등의 변수가 이에 해당합니다. '원본 이미지'의 크기를 설정하면 해당 이미지의 일부만을 디스플레이할 때 유용합니다. 자세한 사항은 아래 도식을 참고하세요.",
      "params": ["p5.Image, p5.Element: 디스플레이할 이미지",
      "숫자: 왼쪽 위 모서리의 x 좌표",
      "숫자: 왼쪽 위 모서리의 y 좌표",
      "숫자: 이미지 너비 설정",
      "숫자: 이미지 높이 설정",
      "숫자: 원본 이미지를 배치할 목적지 사각형의 x 좌표",
      "숫자: 원본 이미지를 배치할 목적지 사각형의 y 좌표",
      "숫자: 목적지 사각형의 너비",
      "숫자: 목적지 사각형의 높이",
      "숫자: 목적지 사각형에 배치할 원본 이미지 일부의 x좌표",
      "숫자: 목적지 사각형에 배치할 원본 이미지 일부의 y좌표",
      "숫자: 목적지 사각형에 배치할 원본 이미지 일부의 너비",
      "숫자: 목적지 사각형에 배치할 원본 이미지 일부의 높이"]
    }
  },
    "tint": {
      "description": "定义显示图像的填色值。图像能着色成所定义的颜色或提供透明度值以使其透明化。<br><br>如想是图像透明化但不想影响其颜色，可使用白色为着色值并定义透明度值。比如说，tint(255, 128) 将会使一个图像成为 50% 透明（假设为默认透明度范围 0-255，可使用 colorMode() 调整）。<br><br>灰阶值参数必须低于或等于当时 colorMode() 所定义的最高值。默认最高值为 255。",
      "params": ["数字：红彩值或色调值，需在被定义的范围内",
                 "数字：绿彩值或饱和度值，需在被定义的范围内",
                 "数字：蓝彩值或亮度值，需在被定义的范围内",
                 "数字：",
                 "字符串：颜色字符串",
                 "数字：灰阶值",
                 "数字[]：一个有红、绿、蓝及透明度值的数组",
                 "p5.Color：着色色值"],
      "returns": ""
    },
    "noTint": {
      "description": "移除当时显示图像的填色值并将其恢复成显示图形的原色调。",
      "returns": ""
    },
    "imageMode": {
      "description": "定义图像模式。更改 image() 解读参数的方式以更改图像开始绘制的位置。默认模式为 imageMode(CORNER)，此模式将解读第二及第三个参数为图像的左上角位置。如果加多两个参数，它们则被用来定义图像的宽度和高度。<br><br>imageMode(CORNERS) 将使 image() 函数解读第二及第三个参数为一个角落的位置，而第四个第五个参数为对面角落的位置。<br><br>imageMode(CENTER) 将使 image() 函数解读第二及第三个参数为图像的中心点。如果提供多两个参数，它们将被用来定义图像的宽度和高度。",
      "params": ["常量：CORNER、CORNERS 或 CENTER"],
      "returns": ""
    },
    "pixels": {
      "description": "此数组为一个储存显示窗口内所有像素值的 Uint8ClampedArray。这些值都为数字。这数组的大小为（同时考虑像素密度）显示窗口的大小 x4，分别代表每个像素由左到右，上到下的 R、G、B、A 值。视网膜显示及其他高密度显示器将会有更多像素（pixelDensity^2 倍）。比如说，如果图像为 100x100 像素，总共会有 40,000 个元素在 pixels[] 数组内。而在一个视网膜显示，将会有 160,000 个元素。<br><br>数组内最初四个值（指数 0-3）将会是在坐标 (0, 0) 的像素的 R、G、B、A 值。下四个值（指数 4-7）将会是在坐标 (1, 0) 的像素的 R、G、B、A 值。一般上，如果要设置像素 (x, y) 的值： <pre>CODE BLOCK PENDING</pre> 虽然以上的方式有点复杂，它能提供足够的弹性以应对任何像素密度的显示。注意 set() 将会自动处理设定所有在任何像素密度下 (x, y) 坐标在 pixels[] 内的值，不过程序性能可能在像素数组被更改很多次时时不佳。<br><br>在使用这个数组之前，像素资料必须先使用 loadPixels() 函数加载。在数组资料被修改后，updatePixels() 函数必须被调用以更新图像资料。<br><br>注意这不是个普通的 Javascript 数组。这表示 Javascript 数组函数如 <code>slice()</code> 或 <code>arrayCopy()</code> 将不会有效果。",
      "returns": ""
    },
    "blend": {
      "description": "将一个图像内一个区域的像素复制去另一个图像，同时使用所定义的混合模式执行复制。",
      "params": ["p5.Image：原图像",
                 "整数：原图像的左上角 x 坐标",
                 "整数：原图像的左上角 y 坐标",
                 "整数：原图像的宽度",
                 "整数：原图像的高度",
                 "整数：终点图像左上角的 x 坐标",
                 "整数：终点图像左上角的 y 坐标",
                 "整数：终点图像的宽度",
                 "整数：终点图像的高度",
                 "常量：混合模式。BLEND、DARKEST、LIGHTEST、DIFFERENCE、MULTIPLY、EXCLUSION、SCREEN、REPLACE、OVERLAY、HARD_LIGHT、SOFT_LIGHT、DODGE、BURN、ADD 或 NORMAL。"],
      "returns": ""
    },
    "copy": {
      "description": "将画布内一个区域的像素复制去画布内另外一个区域同时也复制一个由 srcImg 参数所定义的图像内一个区域的像素去定义 srcImage 的画布上，这将是原图像。如果原图像与重点区域的大小不同，它将会自动缩放原图像的像素以符合所定义的终点区域。",
      "params": ["p5.Image：原图像",
                 "整数：原图像的左上角 x 坐标",
                 "整数：原图像的左上角 y 坐标",
                 "整数：原图像的宽度",
                 "整数：原图像的高度",
                 "整数：终点图像左上角的 x 坐标",
                 "整数：终点图像左上角的 y 坐标",
                 "整数：终点图像的宽度",
                 "整数：终点图像的高度"],
      "returns": ""
    },
    "filter": {
      "description": "在画布上使用过滤器。<br><br>预设选择为：<br><br>THRESHOLD 将图像转换成黑与白像素，取决于它们是否高于或低于所定义的 level 参数值。参数值必须在 0.0（黑色）与 1.0（白色）之间。如果并没有提供参数的话，默认将设为 0.5。<br><br>GRAY 将图像内的颜色转换成灰阶色。不使用任何参数。<br><br>OPAQUE 设置所有透明度值成完全不透明。不使用任何参数。<br><br>INVERT 设置每个像素成其反值。不使用任何参数。<br><br>POSTERIZE 将限制每个图像的彩色通道至参数所定义的颜色数。参数值可以介于 2 至 255 之间，但是效果会在较低值是比较明显。<br><br>BLUR 将使用 level 参数所定义的模糊度执行高斯模糊。如果没有提供参数，模糊度为高斯模糊半径为 1。越大的值越模糊。<br><br>ERODE 减少亮区。不使用任何参数。<br><br>DILATE 增加亮区。不使用任何参数。",
      "params": ["常量：THRESHOLD、GRAY、OPAQUE、INVERT、POSTERIZE、BLUR、ERODE、DILATE 或 BLUR。",
                 "数字：每个过滤器独有的可选性参数，请看以上"],
      "returns": ""
    },
    "get": {
      "description": "返回任何像素值的一个为 [R,G,B,A] 的数组或捕捉图像的一部分。如果没有提供任何参数，将会返回整个图像。可使用 x 及 y 参数以取得一个像素的值。多加定义 w 及 h 参数可取的显示窗口的一部分。当在取得图像时，x 及 y 参数将定义图像的左上角坐标值，无论当时的图像模式为何。<br><br>如果欲取得的像素在图像外，将返回 [0,0,0,255]。以取得根据当时的颜色值范围及颜色模式的数字，请使用 getColor 而不是 get。<br><br>使用 get(x, y) 以取得一个像素的颜色相对来说简单，但是其速度并没有直接从 pixels[] 数组获取数据来的快。与使用 get(x, y) 有相同的效果但使用 pixels[] 及像素密度 d 的范例如下 <code>var x, y, d; // 设置这为坐标 var off = (y width + x) d * 4; var components = [ pixels[off], pixels[off + 1], pixels[off + 2], pixels[off + 3] ]; print(components);</code><br><br>请参考 pixels[] 文献以知更多详情。",
      "params": ["数字：像素的 x 坐标",
                 "数字：像素的 y 坐标",
                 "数字：宽度",
                 "数字：高度"],
      "returns": "数字[]|p5.Image：在 x,y 的像素值数组或 p5.Image"
    },
    "loadPixels": {
      "description": "将显示窗口的像素资料加载到 pixels[] 数组里。这函数必须在读写 pixels[] 之前被调用。注意只有使用 set() 或直接修改 pixels[] 的改变会发生。",
      "returns": ""
    },
    "set": {
      "description": "改变任何像素的颜色，或直接在显示窗口内绘画一个图像。<br><br>x 及 y 参数用于定义该改变的像素而 c 参数用于定义颜色值。这可以是一个 p5.Color 物件或一个 [R, G, B, A] 像素数组。它也能是一个灰阶值。在设定一个图像时，x 及 y 参数将定义图像左上角的坐标值，无论当时的图像模式为何。<br><br>在使用 set() 后，您必须调用 updatePixels() 以使您的改变生效。这应该在所有像素都被设定后才被调用，而且也必须在调用 get() 或绘制图像之前调用。<br><br>使用 set(x, y) 设置一个像素的颜色相对来说简单，但使其速度并没有直接将数据写在 pixels[] 数组里来的快。直接使用 pixels[] 设置像素值可能在使用视网膜显示器时比较复杂，不过它会在每一个循环有很多像素需要被设定时表现得更好。<br><br>请参考 pixels[] 文献以知更多详情。",
      "params": ["数字：像素的 x 坐标",
                 "数字：像素的 y 坐标",
                 "数字|数字[]|物件：插入一个灰阶值 | 一个像素数组 | 一个 p5.Color 物件 | 一个用于复制的 p5.Image"],
      "returns": ""
    },
    "updatePixels": {
      "description": "使用 pixels[] 数组内的资料更新显示窗口。通常与 loadPixels() 一起使用。如果您只需从该数组中读取像素资料，您不需要调用 updatePixels() — 更新只有在进行更改时需要被调用。updatePixels() 应该在像素数组被更改或 set() 被调用时使用，只有使用 set() 或直接修改 pixels[] 的改变会发生。",
      "params": ["数字：欲更新的区域的左上角 x 坐标",
                 "数字：欲更新的区域的左上角 y 坐标",
                 "数字：欲更新的区域的宽度",
                 "数字：欲更新的区域的高度"],
      "returns": ""
    },
    "loadFont": {
      "description": "从一个文件或网址加载一个 opentype 字形文件（.otf、.ttf），将返回一个 p5.Font 物件。这函数为异步进行，这表示它可能不会在您绘图的下一行代码执行前完成。<br><br>字形的路径应该相对于链接您的绘图的 HTML 文件。从其他 URL 或远程位置加载字形可能会被浏览器的内建安全模式阻止。",
      "params": ["字符串：该加载的字形名字或网址",
                 "函数：在 loadFont() 完成后该调用的函数",
                 "函数：在发生错误时该调用的函数"],
      "returns": "p5.Font：p5.Font 物件"
    },
    "loadJSON": {
      "description": "从一个文件或网址加载一个 JSON 文件，将返回一个物件。注意如果该 JSON 文件内涵一个数组，此函数仍然会返回一个以数字为指数的物件。<br><br>这函数为异步进行，这表示它可能不会在您绘图的下一行代码执行前完成。JSONP 功能支持是由填充工具所提供而您可以使用第二个参数来定义一个有 JSON 回调定义的物件，只需跟从这里的<a href='https://github.com/camsong/fetch-jsonp'>指示</a>。",
      "params": ["字符串：该加载的文件名或网址",
                 "物件：关于 jsonp 设置的设置物件",
                 "字符串：\"json\" 或 \"jsonp\"",
                 "函数：在 loadJSON() 完成后该执行的函数，返回的数据将会是函数第一个参数",
                 "函数：在发生错误时该执行的函数，回复将会是函数第一个参数"],
      "returns": "物件：JSON 数据"
    },
    "loadStrings": {
      "description": "读取一个文件的内容并使用个别字行创造一个字符串数组。如果文件名被用作第一个参数，如以上范例，该文件必须被储存在绘图文件夹内。<br><br>除此之外，该文件也能从本地电脑任何位置加载，只需使用绝对路径（任何在 Unix 及 Linux 内由 / 开始的路径，或在 Windows 内由驱动器符号开始的路径），又或者任何在网络上的文件网址也能用来当作 filename 参数。<br><br>这函数为异步进行，这表示它可能不会在您绘图的下一行代码执行前完成。",
      "params": ["字符串：该加载的文件名或网址",
                 "函数：在 loadStrings() 完成后该执行的函数，返回的数组将会是函数第一个参数",
                 "函数：在发生错误时该执行的函数，回复将会是函数第一个参数"],
      "returns": "字符串[]：字符串数组"
    },
    "loadTable": {
      "description": "读取一个文件的内容并使用其内容创造一个 p5.Table 物件。如果文件名被用作第一个参数，该文件必须被储存在绘图文件夹内。文件名参数也能是一个在网络上的文件的网址。默认上，该文件被假定为以逗号分隔（格式为 CSV）。该表格只会在 ‘header’ 设置被使用时才会寻找标签。<br><br>可使用的设置包括：<ul><li>csv - 将表格解析为逗号分隔值</li><li>tsv - 将表格解析为制表符分隔值</li><li>header - 这表格有标签行</li></ul><br><br>当使用多个设置时，您只需将他们分为个别的参数并使用逗号分隔。例如：<br><br><code>loadTable('my_csv_file.csv', 'csv', 'header'); </code><br><br>所有加载及储存的文件都需使用 UTF-8 编码。<br><br>这函数为异步进行，这表示它可能不会在您绘图的下一行代码执行前完成。在 preload() 内调用 loadTable() 将保证加载工作会在 setup() 及 draw() 被调用前完成<br><br>在 preload() 外，您可以提供一个回调函数以处理加载物件。",
      "params": ["字符串：该加载的文件名或网址",
                 "字符串：\"header\" \"csv\" \"tsv\"",
                 "函数：在 loadTable() 完成后该执行的函数，返回的 Table 物件将会是函数第一个参数",
                 "函数：在发生错误时该执行的函数，回复将会是函数第一个参数"],
      "returns": "物件：含有数据的 Table 物件"
    },
    "loadXML": {
      "description": "读取一个文件的内容并使用其内容创造一个 XML 物件。如果文件名被用作第一个参数，该文件必须被储存在绘图文件夹内。<br><br>除此之外，该文件也能从本地电脑任何位置加载，只需使用绝对路径（任何在 Unix 及 Linux 内由 / 开始的路径，或在 Windows 内由驱动器符号开始的路径），又或者任何在网络上的文件网址也能用来当作 filename 参数。<br><br>这函数为异步进行，这表示它可能不会在您绘图的下一行代码执行前完成。在 preload() 内调用 loadTable() 将保证加载工作会在 setup() 及 draw() 被调用前完成<br><br>在 preload() 外，您可以提供一个回调函数以处理加载物件。",
      "params": ["字符串：该加载的文件名或网址",
                 "函数：在 loadXML() 完成后该执行的函数，返回的 XML 物件将会是函数第一个参数",
                 "函数：在发生错误时该执行的函数，回复将会是函数第一个参数"],
      "returns": "物件：含有数据的 XML 物件"
    },
    "loadBytes": {
      "description": "",
      "params": ["字符串：该加载的文件名或网址",
                 "函数：在 load() 完成后该执行的函数",
                 "函数：在发生错误时该执行的函数"],
      "returns": "物件：一个 ‘bytes’ 属性将为被加载的缓冲区的物件"
    },
    "httpGet": {
      "description": "执行 HTTP GET 请求的函数。如果数据类型（datatype）没有被定义的话，p5 将会尝试根据网址猜返回数据的类型，默认为文字。这和调用 httpDo(path, 'GET') 的效果一样。‘binary’ 数据类型将会返回一个 Blob 物件，而 ‘arrayBuffer’ 数据类型将会返回一个 ArrayBuffer 并可用来创造类型化数组（如 Uint8Array）。",
      "params": ["字符串：该加载的文件名或网址",
                 "字符串：\"json\"、\"jsonp\"、\"binary\"、\"arrayBuffer\"、\"xml\"或\"text\"",
                 "物件|布尔值：与请求一起传送的参数资料",
                 "函数：在 httpGet() 完成后该执行的函数，返回的资料物件将会是函数第一个参数",
                 "函数：在发生错误时该执行的函数，回复将会是函数第一个参数"],
      "returns": ""
    },
    "httpPost": {
      "description": "执行 HTTP POST 请求的函数。如果数据类型（datatype）没有被定义的话，p5 将会尝试根据网址猜返回数据的类型，默认为文字。这和调用 httpDo(path, 'POST') 的效果一样。",
      "params": ["字符串：该加载的文件名或网址",
                 "字符串：\"json\"、\"jsonp\"、\"xml\" 或 \"text\"。如果不提供此参数，httpPost() 将尝试猜",
                 "物件|布尔值：与请求一起传送的参数资料",
                 "函数：在 httpPost() 完成后该执行的函数，返回的资料物件将会是函数第一个参数",
                 "函数：在发生错误时该执行的函数，回复将会是函数第一个参数"],
      "returns": ""
    },
    "httpDo": {
      "description": "执行 HTTP 请求的函数。如果数据类型（datatype）没有被定义的话，p5 将会尝试根据网址猜返回数据的类型，默认为文字。<br><br>如果需要更高等的使用法，您可以在第一个参数给予路径而第二个参数给予一个物件，物件内容设置与 Fetch API 规范的一样。",
      "params": ["字符串：该加载的文件名或网址",
                 "字符串：\"GET\"、\"POST\" 或 \"PUT\"，默认为 \"GET\"",
                 "字符串：\"json\"、\"jsonp\"、\"xml\" 或 \"text\"",
                 "物件|布尔值：与请求一起传送的参数资料",
                 "函数：在 httpDo() 完成后该执行的函数，返回的资料物件将会是函数第一个参数",
                 "函数：在发生错误时该执行的函数，回复将会是函数第一个参数",
                 "物件：Request 物件，请参考 “fetch” API <a href='https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API'>文献</a>以了解可使用设置"],
      "returns": ""
    },
    "createWriter": {
      "description": "",
      "params": ["字符串：该创造的文件的名",
                 "字符串："]
    },
    "save": {
      "description": "储存一个图像、文字、JSON、csv、wav 或 html 文件。将提示客户电脑下载文件。<b>注意 save() 函数不建议在正在循环执行的 draw 函数内使用，因为每一次被调用 save() 函数将会弹出一个储存对话框。</b><br><br>默认上此函数将储存画布成一个图像。您也可以选择定义一个文件名。例如：<pre>CODE BLOCK PENDING</pre>除此之外，第一个参数也能是个画布 p5.Element 的对象、字符串数组、JSON 数组、JSON 物件、p5.Table、p5.Image 或 p5.SoundFile（需要 p5.sound）。第二个参数为文件名（包括扩展名）。第三个参数适用于特别给这一类物件的设定。这函数将会储存一个符合给予的参数的文件。例如：<pre>CODE BLOCK PENDING</pre>",
      "params": ["物件|字符串：如果所提供的是文件名，此函数将会使用该文件名加上 png 或 jpg 文件扩展名来储存画布为一个图像。如果所提供的是物件，此函数则会一物件所定义的方式储存文件（请参考以上范例）。",
                 "字符串：如果所提供的第一个参数为物件，那第二个参数则定义文件名，同时必须包括适当的文件扩展名（请参考以上范例）。",
                 "布尔值|字符串：依文件类型而定的设定。比如说，在储存 JSON 时，true 表示输出文件将会针对文件大小进行优化，而同时牺牲可读性。"],
      "returns": ""
    },
    "saveJSON": {
      "description": "将一个数组或 JSON 物件的内容写进一个 .json 文件内。文件的储存方式及地点在不同浏览器之间有所不同。",
      "params": ["数组|物件：",
                 "字符串：",
                 "布尔值：如果为 true，将移除输出文件内的换行符及空格以优化文件大小（但牺牲可读性）"],
      "returns": ""
    },
    "saveStrings": {
      "description": "将一个字符串数组写进一个文字文件内，每一行为每一组字符串。文件的储存方式及地点在不同浏览器之间有所不同。",
      "params": ["字符串[]：该输出的字符串数组",
                 "字符串：输出文件的名字",
                 "字符串：文件扩展名"],
      "returns": ""
    },
    "saveTable": {
      "description": "将一个表格（Table）物件的内容写进一个文件内。默认将储存为逗号分隔值（'csv'）的文字文件但也可以使用制表符分隔（'tsv'）或生成一个 HTML 表格（'html'）。文件的储存方式及地点在不同浏览器之间有所不同。",
      "params": ["p5.Table：该储存在文件内的表格物件",
                 "字符串：储存表格文件的名字",
                 "字符串：可以是 \"tsv\"、\"csv\" 或 \"html\""],
      "returns": ""
    },
    "p5.Table": {
      "description": "Los objetos Table almacenan datos con múltiples filas y columnas, tal como una hoja de cálculo tradicional. Los objetos Table pueden ser generados desde cero, dinámicamente, o usando datos desde un archivo existente.",
      "params": ["Arreglo: un arreglo de objetos p5.TableRow"],
      "returns": "p5.Table: 该 p5 物件.Table generado"
    },
    "p5.TableRow": {
      "description": "Un objeto TableRow representa una única fila de datos, grabados en columnas, de una tabla. Un objeto TableRow contiene tanto un arreglo ordenado, como un objeto JSON desordenado.",
      "params": ["String: opcional, puebla la fila con una serie de valores, separados por el separador",
      "String: por defecto, valores separados por coma (csv)"],
      "returns": "该 p5 物件"
    },
    "day": {
      "description": "p5.js 将与您的电脑的时钟沟通，day() 函数将返回当天的日期天数在 1 - 31 的范围内。",
      "returns": "整数：当天的日期天数"
    },
    "hour": {
      "description": "p5.js 将与您的电脑的时钟沟通，hour() 函数将返回当时时间的小时数在 0 - 23 的范围内。",
      "returns": "整数：当时时间的小时数"
    },
    "minute": {
      "description": "p5.js 将与您的电脑的时钟沟通，minute() 函数将返回当时时间的分钟数在 0 - 59 的范围内。",
      "returns": "整数：当时时间的分钟数"
    },
    "millis": {
      "description": "返回自程序开始以来的毫秒（一秒的一千分之一）数。这资料一般可用于定时事件及动画序列。",
      "returns": "整数：自程序开始以来的毫秒数"
    },
    "month": {
      "description": "p5.js 将与您的电脑的时钟沟通，month() 函数将返回当天的日期月数在 1 - 12 的范围内。",
      "returns": "整数：当时日期的月数"
    },
    "second": {
      "description": "p5.js 将与您的电脑的时钟沟通，second() 函数将返回当时时间的秒数在 0 - 59 的范围内。",
      "returns": "整数：当时时间的秒数"
    },
    "year": {
      "description": "p5.js 将与您的电脑的时钟沟通，year() 函数将返回当天的日期年数为一个整数（2014、2015、2016等等）。",
      "returns": "整数：当时日期的年数"
    },
    "p5.XML": {
      "description": "XML es una representación de un objeto XML, capaz de procesar código XML. Usa loadXML() para cargar archivos externos XML y crear objetos XML",
      "params": ["String:"],
      "returns": "p5.XML: 该 p5 物件.XML generado"
    },
    "createVector": {
      "description": "创造一个新的 p5.Vector 向量（用以储存向量的数据类型）。此函数将提供一个二维或三维的向量，准确来说一个欧几里得（也称为几何）向量。向量为一个有大小及方向的量。",
      "params": ["数字：该向量的 x 分量",
                 "数字：该向量的 y 分量",
                 "数字：该向量的 z 分量"],
      "returns": "p5.Vector"
    },
    "p5.Vector": {
      "description": "Una clase para describir un vector de dos o tres dimensiones, específicamente un vector euclideano (también conocido como geométrico). Un vector es una entidad que tiene tanto magnitud como dirección. El tipo de datos, sin embargo, graba los componentes del vector (x, y para 2D y x,y,z para 3D). La magnitud y la dirección pueden ser calculados con los métodos mag() y heading(). En muchos de los ejemplos de p5.js, verás que p5.Vector es usado para describir una posición, velocidad o aceleración. Por ejemplo, si consideras un rectángulo moviéndose a lo largo de la pantalla, en cada instante tiene una posición (un vector que apunta desde el origen hasta su ubicación), una velocidad(la tasa a la que la posición del objeto cambia por unidad de tiempo, expresada como vector), y aceleración (la tasa a la que la velocidad del objeto cambia por unidad de tiempo, expresada como vector). Como los vectores representan grupos de valores, no podemos simplemente usar las operaciones tradicionales de adición, multiplicación, etc. En vez de eso, necesitaremos hacer matemática de vectores, lo que es simplificado con los métodos dentro de la clase p5.Vector.",
      "params": ["Número: componente x del vector",
                 "Número: componente y del vector",
                 "Número: componente z del vector"],
      "returns": "该 p5 物件"
    },
    "abs": {
      "description": "计算一个数字的绝对值（大小值）。映射到 Math.abs()。一个数字的绝对值一定是个正数。",
      "params": ["数字：用于计算的数字"],
      "returns": "数字：被给予数字的绝对值"
    },
    "ceil": {
      "description": "计算最靠近并大于或等于参数值的整数。映射到 Math.ceil()。比如说，ceil(9.03) 将返回 10。",
      "params": ["数字：该取整的数字"],
      "returns": "整数：取整后的数字"
    },
    "constrain": {
      "description": "限制一个数字于最低值与最高值之间。",
      "params": ["数字：该限制的数字",
                 "数字：最低值",
                 "数字：最高值"],
      "returns": "数字：被限制后的数字"
    },
    "dist": {
      "description": "计算两点之间的距离。",
      "params": ["数字：第一个点的 x 坐标",
                 "数字：第一个点的 y 坐标",
                 "数字：第二个点的 x 坐标",
                 "数字：第二个点的 y 坐标",
                 "数字：第一个点的 z 坐标",
                 "数字：第二个点的 z 坐标"],
      "returns": "数字：两点之间的距离"
    },
    "exp": {
      "description": "返回欧拉数 e （2.71828...）提升到由参数 n 定义的指数。映射到 Math.exp()。",
      "params": ["数字：该提升的指数"],
      "returns": "数字：e^n"
    },
    "floor": {
      "description": "计算最靠近并小于或等于参数值的整数。映射到 Math.floor()。",
      "params": ["数字：该取整的数字"],
      "returns": "整数：取整后的数字"
    },
    "lerp": {
      "description": "计算一个介于两个数字之间所定义的插值量位置的数字。amt 参数为两个值之间的插值量，0.0 为第一个值，0.1 为非常接近第一个值，0.5 为两者之间等等。lerp 函数可用来沿着直线制作动画及绘制虚线。",
      "params": ["数字：第一个值",
                 "数字：第二个值",
                 "数字：介于 0.0 与 1.0 之间的数字"],
      "returns": "数字：插值"
    },
    "log": {
      "description": "计算一个数字的自然对数（e 为底数的对数）。这函数需要 n 参数大于 0.0。映射到 Math.log()。",
      "params": ["数字：大于 0 的数字"],
      "returns": "数字：n 的自然对数"
    },
    "mag": {
      "description": "计算一个向量的大小（或长度）。向量为一个空间内的方向，通常用于电脑图形及线性代数。因为它没有“开始”位置，一个向量的大小可以被想成是 0,0 坐标与向量 x,y 坐标之间的距离。因此，mag() 是 dist(0, 0, x, y) 的缩写。",
      "params": ["数字：第一个值",
                 "数字：第二个值"],
      "returns": "数字：从 (0, 0) 至 (a, b) 的向量的大小"
    },
    "map": {
      "description": "从一个范围内映射一个数字去另一个范围。<br><br>在以上第一个范例，25 被从 0 至 100 之间的范围映射去窗口最左方 (0) 至最右方 (width) 的范围内。",
      "params": ["数字：该转换的值",
                 "数字：现在值的最低值",
                 "数字：现在值的最低值",
                 "数字：目标值的最低值",
                 "数字：目标值的最高值",
                 "布尔值：限制目标值在最高及最低值之间"],
      "returns": "数字：映射后的数字"
    },
    "max": {
      "description": "找出一系列数字中最大的值，并返回该值。max() 能接受任何数量的数字参数，或是一个任何大小的数组。",
      "params": ["数字：用于比较的数字",
                 "数字：用于比较的数字",
                 "数字[]：用于比较的数字"],
      "returns": "数字：最高值的数字"
    },
    "min": {
      "description": "找出一系列数字中最小的值，并返回该值。min() 能接受任何数量的数字参数，或是一个任何大小的数组。",
      "params": ["数字：用于比较的数字",
                 "数字：用于比较的数字",
                 "数字[]：用于比较的数字"],
      "returns": "数字：最低值的数字"
    },
    "norm": {
      "description": "将一个数字由一个范围标准化成介于 0 及 1 之间的值。与 map(value, low, high, 0, 1) 的效果相同。在范围外的数字将不会被限制在 0 与 1 之间，因为范围外的值通常是有意及有用的。（参考以上第二个范例）",
      "params": ["数字：该标准化的值",
                 "数字：现在值的最低值",
                 "数字：现在值的最高值"],
      "returns": "数字：标准化后的数字"
    },
    "pow": {
      "description": "执行幂运算。pow() 函数是个能有效率地将数字大量乘于自己（或其倒数）的方式。比如说，pow(3, 5) 等同于 3*3*3*3*3 而 pow(3, -5) 等同于 1 / (3*3*3*3*3)。映射到 Math.pow()。",
      "params": ["数字：幂运算的底数",
                 "数字：幂运算的指数"],
      "returns": "数字：n^e"
    },
    "round": {
      "description": "计算最靠近 n 参数的整数。比如说，round(133.8) 将返回 134。映射到 Math.round()。",
      "params": ["数字：该取整的数字"],
      "returns": "整数：取整后的数字"
    },
    "sq": {
      "description": "平方一个数字（将数字乘于自己）。结果一定是个正数，因为将两个负数相乘一定会有一个正数结果。比如说 -1 * -1 = 1。",
      "params": ["数字：该平方的数字"],
      "returns": "数字：平方后的数字"
    },
    "sqrt": {
      "description": "计算一个数字的平方根。一个数字的平方根一定是个正数，虽然也可能有正确的负数平方根。一个数字 a 的平方根 s 有以下属性 s*s = a。此函数为取平方的相反。映射到 Math.sqrt()。",
      "params": ["数字：该取平方根的非负数"],
      "returns": "数字：取平方根后的数字"
    },
    "noise": {
      "description": "返回所定义坐标的柏林噪声值。柏林噪声是个用来生成比 random() 所能生成更自然及更谐波的随机数字系列。在 1980 年代有 Ken Perlin 所发明，柏林噪声至今常被用在图形应用程序中生成程序纹理、自然运动、形状、地形等等。<br><br>柏林噪声与 random() 函数最主要的不同点在于前者是在一个无限的 n 维空间内定义的，这空间内每一对坐标都相对于一个固定的半随机值（只有在程序进行时为固定的；请参考 noiseSeed() 函数）。p5.js 能计算 1 维、2 维及 3 维噪声，这取决于所给予的坐标数。返回的值一定会在 0.0 至 1.0 之间。噪音值可以通过在噪音空间内移动以制成动画，如以上范例所示。第二及第三个空间维度也能被解读成时间。<br><br>所生成的噪音结构上和一般音频信号相似，尤其是此函数的频率。与物理学上谐波的概念相似，泊林噪音也是在计算几个八度后再将其结果加起来以得到最后的结果。<br><br>另外一个控制返回随机数系列的特征的方法是控制输入坐标值的大小。因为此函数能在无限之的空内内应用，输入坐标的值并不重要，只有个别坐标之间的距离需要被注意（如在循环内使用 noise() 时）。一般来说坐标之间的距离越小，生成噪声随机数列将会越平滑。介于 0.005-0.03 之间的距离应该适合大多数应用场合，不过这可能因应用需求而变。",
      "params": ["数字：噪声空间的 x 坐标",
                 "数字：噪声空间的 y 坐标",
                 "数字：噪声空间的 z 坐标"],
      "returns": "数字：柏林噪声在特定坐标的值（介于 0 与 1 之间）"
    },
    "noiseDetail": {
      "description": "调整柏林噪声函数所生成的噪声特征及细节度。与物理学上谐波的概念相似，泊林噪音也是在计算几个八度后才得到最后的结果。越低的八度将会影响输出信号值越多因此同时会定义噪音的整体强度，而较高的八度将会在噪音系列中制作更精细的细节。<br><br>默认上，此噪音将使用四个八度计算而每个八度将有其前者一半的影响力，第一个八度的影响力为 50% 。这衰退值能通过加多一个参数而改变。比如说如果衰退因数为 0.75 那表示每个八度将会有其前者的 75% 的影响力（减少 25%）。任何介于 0.0 与 1.0 的值都能被接受，不过注意高于 0.5 的值可能会造成 noise() 函数会返回大于 1.0 的值。<br><br>通过改变这些参数，noise() 函数所生成的信号可适应于非常特别的需求或特点。",
      "params": ["数字：噪音该使用的八度数",
                 "数字：每个八度的衰退因数"],
      "returns": ""
    },
    "noiseSeed": {
      "description": "定义 noise() 使用的随机种子值。默认上，noise() 将在每一次改程序被执行时生成不同的结果。只需定义 value 参数至一个常量就能确保每一次软件执行时都会返回一样的随机数列。",
      "params": ["数字：随机种子值"],
      "returns": ""
    },
    "acos": {
      "description": "cos() 的反值，将返回一个值的反余弦值。此函数接受介于 -1 与 1 之间的值并将返回介于 0 与 PI（3.1415927）之间的值。",
      "params": ["数字：该取反余弦值的值"],
      "returns": "数字：该值的反余弦值"
    },
    "asin": {
      "description": "sin() 的反值，将返回一个值的反正弦值。此函数接受介于 -1 与 1 之间的值并将返回介于 -PI/2 与 PI/2 之间的值。",
      "params": ["数字：该取反正弦值的值"],
      "returns": "数字：该值的反正弦值"
    },
    "atan": {
      "description": "tan() 的反值，将返回一个值的反正切值。此函数接受介于 -Infinity 与 Infinity（包括 Infinity）之间的值并将返回介于 -PI/2 与 PI/2 之间的值。",
      "params": ["数字：该取反正切值的值"],
      "returns": "数字：该值的反正切值"
    },
    "atan2": {
      "description": "计算从一个被定义的点到坐标原点的弧度，并由正 x 轴开始计算。将返回介于 PI 与 -PI 之间的浮点数。atan2() 函数通常用于定向几何图形至鼠标的位置。<br><br>注意：第一个参数为 y 坐标，而第二个参数为 x 坐标，这是为了适应计算正切值的结构。",
      "params": ["数字：该点的 y 坐标",
                 "数字：该点的 x 坐标"],
      "returns": "数字：该点的反正切值"
    },
    "cos": {
      "description": "计算一个角度的余弦值。此函数将使用当时的角度模式。返回值将介于 -1 与 1 之间的值。",
      "params": ["数字：角度"],
      "returns": "数字：该角度的余弦值"
    },
    "sin": {
      "description": "计算一个角度的正弦值。此函数将使用当时的角度模式。返回值将介于 -1 与 1 之间的值。",
      "params": ["数字：角度"],
      "returns": "数字：该角度的正弦值"
    },
    "tan": {
      "description": "计算一个角度的正切值。此函数将使用当时的角度模式。返回值将介于 -1 与 1 之间的值。",
      "params": ["数字：角度"],
      "returns": "数字：该角度的正切值"
    },
    "degrees": {
      "description": "将一个弧度值转换成其相对的角度值。弧度和角度为两个测量同样一个东西的方法。一个圆形里有 360 度而也有 2*PI 个弧度。比如说，90° = PI/2 = 1.5707964。此函数将不会使用当时的角度模式。",
      "params": ["数字：由弧度转换成角度的值"],
      "returns": "数字：转换后的角度值"
    },
    "radians": {
      "description": "将一个角度值转换成其相对的弧度值。弧度和角度为两个测量同样一个东西的方法。一个圆形里有 360 度而也有 2*PI 个弧度。比如说，90° = PI/2 = 1.5707964。此函数将不会使用当时的角度模式。",
      "params": ["数字：由角度转换成弧度的值"],
      "returns": "数字：转换后的角度值"
    },
    "angleMode": {
      "description": "定义当时 p5 的角度模式。默认模式为 RADIANS（弧度）。",
      "params": ["常量：RADIANS 或 DEGREES"],
      "returns": ""
    },
    "randomSeed": {
      "description": "定义 random() 使用的随机种子值。<br><br>默认上，random() 将在每一次改程序被执行时生成不同的结果。只需定义 seed 参数至一个常量就能确保每一次软件执行时都会返回一样的伪随机数。",
      "params": ["数字：随机种子值"],
      "returns": ""
    },
    "random": {
      "description": "返回一个随机的浮点数。<br><br>可使用 0、1 或 2 个参数。<br><br>如果并没有定义任何参数，将返回一个介于 0 与 1（但不包括 1）的随机数。<br><br>如果只定义一个参数并且该参数为数字，将返回一个介于 0 与 该数字（但不包括该数字）的随机数。<br><br>如果值定义一个参数并且该参数为数组，将返回该数组中随机一个元素。<br><br>如果定义两个参数，将返回一个介于第一个参数与第二个参数（但不包括第二个参数）的随机数。",
      "params": ["数字：最低值（包括此值）",
                 "数字：最高值（不包括此值）",
                 "数组：供选择的数组"],
      "returns": "数字：随机数"
    },
    "randomGaussian": {
      "description": "返回一个符合高斯，或正态，分布的随机数。理论上 randomGaussian() 没有最高或最低返回值。不过，差均值很多的值被返回的机率将会很低；而接近均质的值被返回的机率将会相对较高。<br><br>可使用 0、1 或 2 个参数。<br>如果并没有定义任何参数，将使用均值为 0 与 标准差为 1。<br>如果只定义一个参数，该参数将为均值（标准差为 1）。<br>如果定义两个参数，第一个参数为均值，第二个参数为标准差。",
      "params": ["数字：均值",
                 "数字：标准偏差"],
      "returns": "数字：随机数"
    },
    "textAlign": {
      "description": "定义绘制问题的对齐方向。使用两个参数：horizAlign（LEFT、CENTER 或 RIGHT）及 vertAlign（TOP、BOTTOM、CENTER 或 BASELINE）。<br><br>horizAlign 参数为 text() 函数的 x 值，而 vertAlign 参数为 y 值。<br><br>因此如果您使用 textAlign(LEFT)，您将会使文字最左方对齐 text() 函数所使用的 x 参数。如果您使用 textAlign(RIGHT, TOP)，您将会使文字最右方对齐 x 值而文字最上方对齐 y 值。",
      "params": ["常量：水平对齐，LEFT、CENTER 或 RIGHT",
                 "常量：垂直对齐，TOP、BOTTOM、CENTER 或 BASELINE"],
      "returns": ""
    },
    "textLeading": {
      "description": "定义或获取行与行之间的像素距离。此设置将会在所有接下来的 text() 函数调用时生效。",
      "params": ["数字：行与行之间的像素距离"],
      "returns": ""
    },
    "textSize": {
      "description": "定义或获取当时的字体大小。这大小将会在所有接下来的 text() 函数调用时生效。字形大小是使用像素定义。",
      "params": ["数字：字体的像素大小"],
      "returns": ""
    },
    "textStyle": {
      "description": "定义或获取系统字体的风格，可以是 NORMAL、ITALIC 或 BOLD。注意：这可能被 CSS 风格所覆盖。至与非系统字体（opentype、truetype 等）请直接加载已风格化的字体。",
      "params": ["常量：字体的风格，可以是 NORMAL、ITALIC 或 BOLD"],
      "returns": ""
    },
    "textWidth": {
      "description": "计算及返回任何字符或字符串的宽度。",
      "params": ["字符串：该测量的字符串"],
      "returns": "数字"
    },
    "textAscent": {
      "description": "返回当时字体在当时所定的大小的整体高度。这高度代表从基准线算起至最高字体的顶点的距离。",
      "returns": "数字"
    },
    "textDescent": {
      "description": "返回当时字体在当时所定的大小的下端线高度。",
      "returns": "数字"
    },
    "text": {
      "description": "将文字绘制在荧幕上。显示第一个参数内的资料在荧幕上由其他参数所定义的位置。将会使用默认字形除非使用 textFont() 函数定义使用其他字形同时也将使用默认大小除非使用 textSize() 定义文字大小。文字的颜色可使用 fill() 函数定义。可使用 stroke() 及 strokeWeight() 函数添加文字外形线。<br><br>文字显示将位于 textAlign() 函数所定义的位置，您可将文字绘制在坐标的左边、右边或中间。<br><br>x2 及 y2 参数将定义一个方形文字显示区而且只适用于字符串资料类型。当这两个参数被定义时，它们将使用当时的 rectMode() 设置被解读。不符合方形大小的文字将不会被绘制在荧幕上。",
      "params": ["字符串|物件|数组|数字|布尔值：该显示的字母数字符号",
                 "数字：文字的 x 坐标",
                 "数字：文字的 y 坐标",
                 "数字：默认上，文字格的宽度，请参考 rectMode()",
                 "数字：默认上，文字格的高度，请参考 rectMode()"],
      "returns": ""
    },
    "textFont": {
      "description": "定义使用 text() 函数绘制文字时该使用的字形。",
      "params": ["物件|字符串：一个使用 loadFont() 加载的字形，或一个代表 Web 安全字体（一个所有系统都通用的字形）的字符串",
                 "数字：字形大小"],
      "returns": ""
    },
    "p5.Font": {
      "description": "Clase base para manipulación de tipografía",
      "params": ["物件：puntero a la instancia p5"],
      "returns": "该 p5 物件"
    },
    "append": {
      "description": "弃用：append() 已被弃用并将会在未来的 p5 版本中移除。请改用 <a href='https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push'>array.push(value)</a>。<br><br>在数组的尾端增加一个值。将增加数组的一个大小。映射到 Array.push()。",
      "params": ["数组：该附加到的数组",
                 "任何：该附加进数组的元素"],
      "returns": ""
    },
    "arrayCopy": {
      "description": "弃用：arrayCopy() 已被弃用并将会在未来的 p5 版本中移除。<br><br>复制一个数组（或该数组的一部分）去另外一个数组。src 数组将会被复制去 dst 数组，开端位置由 srcPosition 参数定义并复制进由 dstPosition 定义的位置。该复制的元素数量由 length 参数定义。注意在复制元素时该元素将覆盖终点数组原有的元素。如果想要添加元素，请使用 use concat()。<br><br>简化版本将只使用两个参数：arrayCopy(src, dst) 将复制整个数组去另一个相同大小的数组。这等同于使用 arrayCopy(src, 0, dst, 0, src.length)。<br><br>使用这函数将比使用 for 循环数组内每一个元素并一一复制来的更有效率。",
      "params": ["数组：原数组",
                 "数字：在原数组内的开端指数",
                 "数组：终点数组",
                 "数字：在终点数组内的开端指数",
                 "数字：该复制的元素量"],
      "returns": ""
    },
    "concat": {
      "description": "弃用：concat() 已被弃用并将会在未来的 p5 版本中移除。请改用 <a href='https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat'>arr1.concat(arr2)</a>。<br><br>串接两个数组，映射到 Array.concat()。将不会修改原有数组。",
      "params": ["数组：串接的第一个数组",
                 "数组：串接的第二个数组"],
      "returns": "数组：串接后的数组"
    },
    "reverse": {
      "description": "弃用：reverse() 已被弃用并将会在未来的 p5 版本中移除。请改用 <a href='https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse'>array.reverse()</a>。<br><br>倒转数组内元素的次序，映射到 Array.reverse()。",
      "params": ["数组：该倒转的数组"],
      "returns": ""
    },
    "shorten": {
      "description": "弃用：shorten() 已被弃用并将会在未来的 p5 版本中移除。请改用 <a href='https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop'>array.pop()</a>。<br><br>将数组减少一个元素并返回缩短后的数组，映射到 Array.pop()。",
      "params": ["数组：该缩短的数组"],
      "returns": "数组：缩短后的数组"
    },
    "shuffle": {
      "description": "弃用：shuffle() 已被弃用并将会在未来的 p5 版本中移除。请参考<a hreh='https://stackoverflow.com/questions/6274339/how-can-i-shuffle-an-array'>使用 Javascript 混洗数组</a>（英文页面）。<br><br>随机排列数组内的元素。使用 Fisher-Yates 混洗函数。",
      "params": ["数组：该混洗的数组",
                 "布尔值：修改所给予的数组"],
      "returns": "数组：混洗后的数组"
    },
    "sort": {
      "description": "弃用：sort() 已被弃用并将会在未来的 p5 版本中移除。请改用 <a href='https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort'>array.sort()</a>。<br><br>将一个含有数字的数组有最小到最大值重新排列，或将一个含有文字的数组依字母顺序排列。原数组将不会被修改，而将会返回重新排列后的数组。count 参数定义该排列的元素量。比如说，如果数组内有 12 个元素而 count 被设为 5，只有数组内前五个元素将会被排列。",
      "params": ["数组：该排列的数组",
                 "整数：该排列的元素数，由 0 开始"],
      "returns": ""
    },
    "splice": {
      "description": "弃用：splice() 已被弃用并将会在未来的 p5 版本中移除。请改用 <a href='https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice'>array.splice()</a>。<br><br>在一个原有的数组内添加一个值或另一数组的值。第一个参数定义该修改的数组，而第二个参数定义该添加的资料。第三个参数为该添加元素的位置的数组指数。（记得数组指数从零开始，因此第一个位置为 0，而第二的位置为 1 等等。）",
      "params": ["数组：拼接进的数组",
                 "任何：欲拼接进数组的值",
                 "整数：数组内该添加该元素的位置"],
      "returns": ""
    },
    "subset": {
      "description": "弃用：subset() 已被弃用并将会在未来的 p5 版本中移除。请改用 <a href='https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice'>array.slice()</a>。<br><br>从一个现有的数组中提取一数组的元素。list 参数定义该复制提取元素的数组，而 start 及 count 参数定义该提取哪一些元素。如果没有提供 count 参数，那将会提取数组由开头到结尾的元素。在定义 start 参数时，记得数组第一个指数为 0。这函数将不会修改原数组。",
      "params": ["数组：该提取元素的数组",
                 "整数：开始位置",
                 "整数：提取元素数"],
      "returns": "数组：提取出来的元素数组"
    },
    "float": {
      "description": "将一个字符串转换成其浮点值。字符串内内容必须是数字，不然将返回 NaN（不是数字）。比如说，float(\"1234.56\") 将返回 1234.56，但 float(\"giraffe\") 将返回 NaN。<br><br>当给予一数组的值时，将返回一个等同大小的浮点数组。",
      "params": ["字符串：该解析的浮点字符串"],
      "returns": "数字：该字符串的浮点值"
    },
    "int": {
      "description": "转换一个布尔值、字符串或浮点值成其整数值。当给予一数组的值时，将返回一个等同大小的整数数组。",
      "params": ["字符串|布尔值|数字：该解析的值",
                 "整数：该转换成的基数",
                 "数组：该解析的值"],
      "returns": "数字：该值的整数值"
    },
    "str": {
      "description": "转换一个布尔值、字符串或数字成其字符串值。当给予一数组的值时，将返回一个等同大小的字符串数组。",
      "params": ["字符串|布尔值|数字|数组：该解析的值"],
      "returns": "字符串：该值的字符串值"
    },
    "boolean": {
      "description": "转换一个数字或字符串成其布尔值。在数字上，任何非零的值（无论正负）都将转换为 true，而零将转换为 false。在字符串上，\"true\" 将转换成 true，而任何其他值都会转换成 false。当给予一数组的数字或字符串时，将返回一个等同大小的布尔值数组。",
      "params": ["字符串|布尔值|数字|数组：该解析的值"],
      "returns": "布尔值：该值的布尔值"
    },
    "byte": {
      "description": "转换一个数字、代表数字的字符串或布尔值成其字节值.一个字节只能是一个介于 -128 与 127 之间的整数，因此如果在这范围外的值被转换时，它将会绕回相对的字节值。当给予一数组的数字、字符串或布尔值时，将返回一个等同大小的字节数组。",
      "params": ["字符串|布尔值|数字：该解析的值",
                 "数组：该解析的值"],
      "returns": "数字：该值的字节值"
    },
    "char": {
      "description": "转换一个数字或字符串成其单一字符的值。如果提供一个字符串参数，它将会先被解析成整数然后再被转换成单一字符。当给予一数组的数字或字符串时，将返回一个等同大小的单一字符数组。",
      "params": ["字符串|数字：该解析的值",
                 "数组：该解析的值"],
      "returns": "字符串：该值的字符串值"
    },
    "unchar": {
      "description": "转换一个单一字符成其整数值。当给予一数组的单一字符值时，将返回一个等同大小的整数数组。",
      "params": ["字符串：该解析的值",
                 "数组：该解析的值"],
      "returns": "数字：该值的整数值"
    },
    "hex": {
      "description": "转换一个数字成其十六进制值的字符串。如果提供第二个参数，它将被用来定义该生成的十六进制值的字符量。当给予一数组时，将返回一个等同大小的十六进制字符串数组。",
      "params": ["数字：该解析的值",
                 "数字",
                 "数字[]：该解析的值"],
      "returns": "字符串：该值的十六进制值"
    },
    "unhex": {
      "description": "转换一个十六进制字符串成其整数值。当给予一数组的十六进制字符串时，将返回一个等同大小的整数数组。",
      "params": ["数字：该解析的值",
                 "数组：该解析的值"],
      "returns": "数字：该十六进制值的整数值"
    },
    "join": {
      "description": "将一数组的字符串合成一个字符串，每一个元素由 separator 参数定义的字符分隔开。如果要连接整数或浮点数数组，它们必须先使用 nf() 或 nfs() 转换成字符串。",
      "params": ["数组：该连接的字符串",
                 "字符串：在个元素之间穿插的字符串"],
      "returns": "字符串：连接后的字符串"
    },
    "match": {
      "description": "这函数可被用来在一段文字上应用正则表达式，并将返回含有符合表达式的组合（在括号内的元素）的字符串数组。如果没找到任何匹配组合，将返回 null。如果正则表达式内没有定义任何组合，但有搜寻到匹配序列，将返回一个大小为 1 的数组（匹配的文字为数组的第一个元素）。<br><br>使用此函数时，先查看结果是否为 null。如果结果为 null，那表示该段文字没有匹配序列。如果有找到匹配序列，将返回一个数组。<br><br>如果正则表达式内有组合（由括号定义），那个别内容将会以数组的形式返回。正则表达式匹配返回的元素 [0] 将会是整个匹配的字符串，而匹配组合将从元素 [1] 开始（第一组为 [1]、第二组为 [2] 等）。",
      "params": ["字符串：在此字符串内搜寻",
                 "字符串：用于搜寻的正则表达式"],
      "returns": "数组：搜寻到的字符串数组"
    },
    "matchAll": {
      "description": "这函数可被用来在一段文字上应用正则表达式，并将返回含有符合表达式的组合（在括号内的元素）的二维字符串数组。如果没找到任何匹配组合，将返回 null。如果正则表达式内没有定义任何组合，但有搜寻到匹配序列，仍然将返回一个二维数组，但第二维度数组的大小将为一。<br><br>使用此函数时，先查看结果是否为 null。如果结果为 null，那表示该段文字没有匹配序列。如果有找到匹配序列，将返回一个二维数组。<br><br>如果正则表达式内有组合（由括号定义），那个别内容将会以数组的形式返回。假设有一个有计算其变量 i 的循环，正则表达式匹配返回的元素 [i][0] 将会是整个匹配的字符串，而匹配组合将从元素 [i][1] 开始（第一组为 [i][1]、第二组为 [i][2] 等）。",
      "params": ["字符串：在此字符串内搜寻",
                 "字符串：用于搜寻的正则表达式"],
      "returns": "字符串[]：搜寻到的二维字符串数组"
    },
    "nf": {
      "description": "用于将数字格式化成字符串的辅助函数。此函数有两个版本：一个用于格式化浮点数，另一个用于格式化整数。参数 left 及 right 的值必须是正整数。",
      "params": ["数字|字符串：该格式化的数字",
                 "整数|字符串：小数点左边的位数",
                 "整数|字符串：小数点右边的位数",
                 "数组：该格式化的数字"],
      "returns": "字符串：格式化后的字符串"
    },
    "nfc": {
      "description": "用于将数字格式化成字符串并在适当的地方添加逗号以示意 1000 位的辅助函数。此函数有两个版本：一个用于格式化整数，另一个用于格式化一数组的整数。参数 right 的值必须是正整数。",
      "params": ["数字|字符串：该格式化的数字",
                 "整数|字符串：小数点左边的位数",
                 "整数|字符串：小数点右边的位数",
                 "数组：该格式化的数字"],
      "returns": "字符串：格式化后的字符串"
    },
    "nfp": {
      "description": "用于将数字格式化成字符串的辅助函数。与 nf() 相似但会在正数前加个 \"+\" 号而在负数前加个 \"-\" 号。此函数有两个版本：一个用于格式化浮点数，另一个用于格式化整数。参数 left 及 right 的值必须是正整数。",
      "params": ["数字|字符串：该格式化的数字",
                 "整数|字符串：小数点右边的位数",
                 "数组：该格式化的数字"],
      "returns": "字符串：格式化后的字符串"
    },
    "nfs": {
      "description": "用于将数字格式化成字符串的辅助函数。与 nf() 相似但会在正数前加个 \" \"（空格）而在负数前加个 \"-\" 号。此函数有两个版本：一个用于格式化浮点数，另一个用于格式化整数。参数 left 及 right 的值必须是正整数。",
      "params": ["数字：该格式化的数字",
                 "整数：小数点左边的位数",
                 "整数：小数点右边的位数",
                 "数组：该格式化的数字"],
      "returns": "字符串：格式化后的字符串"
    },
    "split": {
      "description": "split() 函数映射到 String.split()，它使用一个字符或字符串为分隔号以将另一个字符串拆分成多个部分。delim 参数定义用于标示各个部分之间边界的字符或字符串。将返回一个含有各个部分的字符串数组。<br><br>splitTokens() 函数也与此函数相似，不过它将使用一系列字符以拆分字符串而不是使用特别定义的单一字符或字符串。",
      "params": ["字符串：还拆分的字符串",
                 "字符串：用于分隔资料的字符串"],
      "returns": "字符串[]：字符串数组"
    },
    "splitTokens": {
      "description": "splitTokens() 函数将在一个或多个字符（或 “tokens”）所标示的地方拆分一个字符串。delim 参数将定义用于标示各个部分之间边界的字符或字符串。<br><br>如果 delim 参数没有被定义，此函数将使用任何空白字符拆分。空白字符包括制表符（\\t）、换行符（\\n）、回车符（\\r）、新页符（\\f）及空格。",
      "params": ["字符串：还拆分的字符串",
                 "字符串：用于分隔资料的字符串列"],
      "returns": "字符串[]：字符串数组"
    },
    "trim": {
      "description": "从一个字符串的前端及后端删除空白字符。除了一般的空白字符如空格、回车及制表符之外，这函数也将删除 Unicode “nbsp” 字符。",
      "params": ["字符串：该修剪的字符串",
                 "数组：该修剪的字符串数组"],
      "returns": "字符串：修剪后的字符串"
    },
    "camera": {
      "description": "定义在一个三维绘图内相机的位置。此函数的行为与 gluLookAt 相似，不过它会覆盖原有的模型视图矩阵而不会在原有的模型视图上添加任何变形。当没有给予任何参数时，此函数将定义默认相机为 camera(0, 0, (height/2.0) / tan(PI*30.0 / 180.0), 0, 0, 0, 0, 1, 0);",
      "params": ["数字：相机在 x 轴的位置",
                 "数字：相机在 y 轴的位置",
                 "数字：相机在 z 轴的位置",
                 "数字：代表绘图中心点的 x 坐标",
                 "数字：代表绘图中心点的 y 坐标",
                 "数字：代表绘图中心点的 z 坐标",
                 "数字：相机向上方向量的 x 分量",
                 "数字：相机向上方向量的 y 分量",
                 "数字：相机向上方向量的 z 分量"],
      "returns": ""
    },
    "perspective": {
      "description": "定义透视相机。当没有给予任何参数时，此函数将定义默认相机为 perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) 其中 cameraZ 为 ((height/2.0) / tan(PI60.0/360.0));",
      "params": ["数字：相机视锥的垂直视野，使用角度模式单位定义视野底部到顶部的角度",
                 "数字：相机视锥的长宽比",
                 "数字：视锥近平面的长度",
                 "数字：视锥远平面的长度"],
      "returns": ""
    },
    "ortho": {
      "description": "定义正射相机。",
      "params": ["数字：相机视锥的左平面",
                 "数字：相机视锥的右平面",
                 "数字：相机视锥的底平面",
                 "数字：相机视锥的顶平面",
                 "数字：相机视锥的近平面",
                 "数字：相机视锥的远平面"],
      "returns": ""
    },
    "ambientLight": {
      "description": "使用所定义的颜色创造一个环境光。",
      "params": ["数字：红彩值或色调值，需在被定义的范围内",
                 "数字：绿彩值或饱和度值，需在被定义的范围内",
                 "数字：蓝彩值或亮度值，需在被定义的范围内",
                 "数字：",
                 "字符串：颜色字符串",
                 "数字：灰阶值",
                 "数字[]：一个有红、绿、蓝及透明度值的数组",
                 "p5.Color：环境光色"],
      "returns": ""
    },

    "directionalLight": {
      "description": "使用所定义的颜色及方向创造一个定向光。",
      "params": ["数字：红彩值或色调值，需在被定义的范围内",
                 "数字：绿彩值或饱和度值",
                 "数字：蓝彩值或亮度值",
                 "p5.Vector：光的方向",
                 "数字[]|字符串|p5.Color：颜色数组、CSS 颜色字符串或 p5.Color 颜色值",
                 "数字：x 轴方向",
                 "数字：y 轴方向",
                 "数字：z 轴方向"],
      "returns": ""
    },
    "pointLight": {
      "description": "使用所定义的颜色及灯光位置创造一个点光源。",
      "params": ["数字：红彩值或色调值，需在被定义的范围内",
                 "数字：绿彩值或饱和度值",
                 "数字：蓝彩值或亮度值",
                 "数字：x 轴方向",
                 "数字：y 轴方向",
                 "数字：z 轴方向",
                 "p5.Vector：光的方向",
                 "数字[]|字符串|p5.Color：颜色数组、CSS 颜色字符串或 p5.Color 颜色值"],
      "returns": ""
    },
    "loadShader": {
      "description": "从所定义的顶点及片断着色器文件路径加载自定的着色器。着色器是在背景异步加载的，因此此函数应该在 preload() 内使用。<br><br>现在为止有三种主要的着色器种类。只要相对的参数有在着色器内被定义，p5 将会自动提供相对的顶点、法线、颜色及灯光属性。",
      "params": ["字符串：存有顶点着色器源代码的文件的路径",
                 "字符串：存有片断着色器源代码的文件的路径"],
      "returns": "p5.Shader：由所定义的顶点及片断着色器所创造的着色器物件"
    },
    "createShader": {
      "description": "",
      "params": ["字符串：顶点着色器的源代码",
                 "字符串：片断着色器的源代码"],
      "returns": "p5.Shader：由所定义的顶点及片断着色器所创造的着色器物件"
    },
    "shader": {
      "description": "shader() 函数让其使用者提供自定的着色器以用于在 WEBGL 模式下渲染形状。使用这能使用 loadShader() 加载自定义的着色器。",
      "params": ["p5.Shader：欲用于渲染形状用的 p5.Shader"]
    },
    "normalMaterial": {
      "description": "形状的法线材料。您可在此<a href='https://p5js.org/zh-Hans/examples/3d-materials.html'>范例</a>查看所有可用的材料。",
      "returns": ""
    },
    "texture": {
      "description": "形状的纹理。您可在此<a href='https://p5js.org/zh-Hans/examples/3d-materials.html'>范例</a>查看所有可用的材料。",
      "params": ["p5.Image|p5.MediaElement|p5.Graphics：该渲染成纹理的二维图像"],
      "returns": ""
    },
    "ambientMaterial": {
      "description": "使用所给予颜色定义形状的环境材料。您可在此<a href='https://p5js.org/zh-Hans/examples/3d-materials.html'>范例</a>查看所有可用的材料。",
      "params": ["数字：红彩值或色调值，需在被定义的范围内",
                 "数字：绿彩值或饱和度值",
                 "数字：蓝彩值或亮度值",
                 "数字：透明度",
                 "数字[]|字符串|p5.Color：颜色数组、CSS 颜色字符串或 p5.Color 颜色值"],
      "returns": ""
    },
    "specularMaterial": {
      "description": "使用所给予颜色定义形状的镜面材料。您可在此<a href='https://p5js.org/zh-Hans/examples/3d-materials.html'>范例</a>查看所有可用的材料。",
      "params": ["数字：红彩值或色调值，需在被定义的范围内",
                 "数字：绿彩值或饱和度值",
                 "数字：蓝彩值或亮度值",
                 "数字：透明度",
                 "数字[]|字符串|p5.Color：颜色数组、CSS 颜色字符串或 p5.Color 颜色值"],
      "returns": ""
    },
    "p5.RendererGL": {
      "description": "TODO",
      "returns": "p5: 该 p5 物件"
    },
    "p5.Shader": {
      "description": "Clase Shader para el modo WEBGL",
      "params": ["p5.RendererGL: una instancia de p5.RendererGL que servirá de contexto GL para este nuevo p5.Shader",
      "String: código fuente para el vertex shader (en forma de string)",
      "String: código fuente para el fragment shader (en forma de string)"],
      "methods": ["Wrapper de las funciones gl.uniform. Como almacenamos información de uniform en el shader, la podemos usar para revisar los datos provistos y llamar a la función apropiada."]
    }
  },
    "p5.Image": {
    "loadPixels": {
      "description": "blah",
      "params": ["Numero: blah",
                 "Numero: blah"],
      "returns": "TODO"
    }
  },
  "p5.Element": {
    "description": "Clase base para todos los elementos añadidos al bosuqejo, incluyendo lienzo, buffers de gráficas, y otros elementos HTML. Los métodos en azul están incluidos en la funcionalidad base, los métodos en marrón son añadidos con la biblioteca p5.dom. No se ejecutan directamente, pero los objetos p5.Element son creados llamando a las funciones createCanvas(), createGraphics(), o en la biblioteca p5.dom, createDiv, createImg, createInput, etc.",
    "params": ["String: node DOM envolvente.",
    "Objeto: puntero a instancia p5."],
    "returns": "TODO"
  }
}
