---
title: learn
slug: learn/
---

<style>
  .methodsList {
    font-family: monospace;
    /*white-space: pre;*/
  }

  .additionalInformation {
    width: 100%;
    background-color: #dedeff;
    font-size: 15px;
    padding: 10px;
    margin: 30px 0;
  }

  .toc {
    width: 100%;
    background-color: #eee;
    font-size: 15px;
    padding: 10px;
    margin: 30px 0;
  }

  .toc h3 {
    margin-top: 15px;
  }
</style>

<div id="learn-page">

  {{> sidebar}}

  <div class="column-span">

    <main>
      <script src="//toolness.github.io/p5.js-widget/p5-widget.js"></script>

      {{!-- large title sketch --}}
      {{!-- <iframe src="{{assets}}/learn/basic3D/titleExample.html" width="720" height="350">
      </iframe> --}}

      <h1>Creating Custom Geometry in WebGL</h1>

      <p>p5.js has a number of 3D primitives that can be used to create basic shapes, like <a class="code">box()</a> or <a class="code">sphere()</a>, but p5.js
        is also capable of rendering complex custom geometry, either from files that are created in other 3D software
        (like Blender) or from code. This tutorial will walk through how to import 3D models into p5.js, as well as how
        to create a basic geometry from scratch. </p>

      <div class="additionalInformation">If you are new to 3D it's recommended that you check out the <a
          href="{{root}}/learn/getting-started-in-webgl-coords-and-transform.html">Coordinates and Transformations</a> tutorial before continuing with this tutorial. </div>

      <div class="toc">
        <h3>Table of Contents</h3>
        <ol>
          <li><a href="#3dModels">Loading 3D Models from File</a></li>
          <li><a href="#proceduralGeometry">Creating Basic Procedural Geometry</a></li>
          <li><a href="#glossary">Glossary</a></li>
        </ol>
      </div>

      <h2 id="3dModels">Loading 3D Models from File</h2>

      <p>Custom geometry can be imported into p5.js using either OBJ or STL files. These files are usually generated in
        a 3D modeling tool like Blender, which offers much more control when constructing a 3D scene. This is done using
        the <a class="code" href="{{root}}/reference/#/p5/loadModel">loadModel()</a> method, which should be used within <a class="code">preload()</a>.</p>

      <p>A common issue that can come up with custom models is scaling. Depending on how the model is constructed, it
        might be a much different size when rendered in p5.js, or even be too small to be rendered at all. The
        <a class="code">loadModel()</a> method includes a normalize parameter that will resize the model to something that works better in
        p5.js.</p>

      {{!-- Widget example of teapot model and loadModel --}}
      <script type="text/p5" data-autoplay data-p5-version="{{ version }}">
var teapotModel;

function preload() {
  teapotModel = loadModel('{{assets}}/learn/basic3D/models/teapot.obj', true);
}

function setup() {
  createCanvas(150, 216, WEBGL);
  debugMode();
}

function draw(){
  background(255);
  normalMaterial(); // For effect
  model(teapotModel);
}
      </script>

      <div class="additionalInformation">Note that there is currently no support for STL files with color, although you
        can add color using materials or textures, which you can learn about in the <a href="{{root}}/learn/getting-started-in-webgl-appearance.html">Styling and Appearance</a> tutorial.
      </div>

      <h2 id="proceduralGeometry">Creating Basic Procedural Geometry</h2>

      <p>Geometry can also be defined procedurally using code. This is a great way to create geometry that moves or is
        formed using your own set of rules. There are a number of methods that can be used to create 3D geometry in a
        way that is similar to 2D drawing in p5.js.</p>


      {{!-- Example using triangle and quad --}}
      {{!-- PENDING WebGL quad / triangle bug fix --}}
      <script type="text/p5" data-autoplay data-p5-version="{{ version }}">
      </script>

      <p>There are also methods that offer greater control of the geometry. A shape can be defined point-by-point using
        <a class="code" href="{{root}}/reference/#/p5/beginShape">beginShape()</a>, <a class="code"
          href="{{root}}/reference/#/p5/vertex">vertex()</a>, and <a class="code"
          href="{{root}}/reference/#/p5/endShape">endShape()</a></p>

      {{!-- Example using beginShape and endShape --}}
      <script type="text/p5" data-autoplay data-p5-version="{{ version }}">
function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
}

function draw(){
  background(220);
  
  // click+drag on canvas to look around the shape
  orbitControl();
  
  fill(255,0,0,128)
    
  var numVertices = 100;
  translate(0,numVertices,0)
  rotateY(millis()/1000)
  scale(20)
  beginShape();
  // a simple spiral shape
  for(let i = 0; i < numVertices; i++) {
    vertex(
      sin((i/numVertices*TWO_PI)*5)*sin(i/numVertices*PI)*2,
      -i/10, 
      cos((i/numVertices*TWO_PI)*5)*sin(i/numVertices*PI)*2,
    );
  }
  endShape();
}
      </script>

      <p>There is also a powerful class, p5.Geometry, which p5 uses internally for <a class="code">loadModel()</a> but can also be used to
        define custom geometry, offering tools that can be helpful in calculating faces and normals. </p>


      {{!-- Example using p5.Geometry --}}
      <script type="text/p5" data-autoplay data-p5-version="{{ version }}">
var myGeometry

function setup() {
  createCanvas(400, 400, WEBGL);

  let detailX = 20;
  let detailY = 20;
  myGeometry = new p5.Geometry(detailX,detailY, function() {
    
    // must be detailX + 1, detailY + 1
    for(let x = 0; x <= detailX; x++) {
      for(let y = 0; y <= detailY; y++) {
        this.vertices.push(new p5.Vector(
          x/detailX,
          y/detailY,
          (sin(x/detailX*TWO_PI*4) + cos(y/detailY*TWO_PI)) / 10
          // random()/10
        ))
      }
    }

    // this will attach all our vertices and create faces automatically
    this.computeFaces()
    // this will calculate the normals to help with lighting
    this.computeNormals()
  })
}

function draw() {
  background(220);
  
  orbitControl()
  
  //set a basic light to see that normals are calculated
  pointLight(255,255,0,0,50,-50)
  
  push();
  stroke(128)
  var geoSize = width/2
  rotateY(cos(millis() / 1000)*PI/4)
  translate(-geoSize/2,-geoSize/2)
  scale(geoSize)
  model(myGeometry)
  pop()
}
      </script>

      <h2 id="glossary">Glossary</h2>

      <h3>Procedural</h3>
      <p></p>

      <h3>Model</h3>
      <p>A representation of geometry.</p>

      <h3>STL</h3>
      <p>STL (most often standing for "standard tesselation language") is a file format for 3D models. It only stores
        information about the geometry.</p>

      <h3>OBJ</h3>
      <p>OBJ is an open file format that stores geometry data as well as some material and texture data. In p5.js, we
        are limited to its geometry, although an image can still be mapped to the surface using textures.</p>

      <h3>Faces</h3>
      <p>The solid surface that is generated between three points.</p>

      <h3>Normals</h3>
      <p>The direction that is perpendicular to a face, which is often needed when calculating lighting or using
        materials. </p>

      <h3>Normalization</h3>
      <p>Changing something so that it fits within a standard range.</p>

    </main>

    {{> footer}}

  </div> <!-- end column-span -->

  {{> asterisk}}

</div><!-- end id="get-started-page"  -->